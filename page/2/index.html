<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>baizn的github博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="baizn的github博客">
<meta property="og:url" content="http://baizn.github.io/page/2/index.html">
<meta property="og:site_name" content="baizn的github博客">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="baizn的github博客">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="baizn的github博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/avatar.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">baizn</a></h1>
		</hgroup>

		
				


		
			<div id="switch-btn" class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div id="switch-area" class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives/">所有文章</a></li>
				        
							<li><a href="/tags/">标签云</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<ul class="social">
							
								<li id="Email"><a class="Email" target="_blank" href="/baizhanning@zhubajie.com" title="Email"></a></li>
					        
								<li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/baizn/baizn.github.io" title="GitHub"></a></li>
					        
								<li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
					        
						</ul>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/API/" style="font-size: 12.5px;">API</a> <a href="/tags/Ajax/" style="font-size: 10px;">Ajax</a> <a href="/tags/BFC/" style="font-size: 10px;">BFC</a> <a href="/tags/CORS/" style="font-size: 10px;">CORS</a> <a href="/tags/CSS/" style="font-size: 12.5px;">CSS</a> <a href="/tags/Cache/" style="font-size: 10px;">Cache</a> <a href="/tags/Component/" style="font-size: 12.5px;">Component</a> <a href="/tags/Cookie/" style="font-size: 10px;">Cookie</a> <a href="/tags/Document/" style="font-size: 10px;">Document</a> <a href="/tags/Drag/" style="font-size: 10px;">Drag</a> <a href="/tags/ECMAScript/" style="font-size: 15px;">ECMAScript</a> <a href="/tags/ES6/" style="font-size: 10px;">ES6</a> <a href="/tags/ES6/" style="font-size: 10px;">ES6+</a> <a href="/tags/Float/" style="font-size: 10px;">Float</a> <a href="/tags/Flux/" style="font-size: 10px;">Flux</a> <a href="/tags/Function/" style="font-size: 10px;">Function</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/MEAT/" style="font-size: 10px;">MEAT</a> <a href="/tags/Object/" style="font-size: 10px;">Object</a> <a href="/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/tags/Props/" style="font-size: 12.5px;">Props</a> <a href="/tags/React/" style="font-size: 17.5px;">React</a> <a href="/tags/React组件/" style="font-size: 10px;">React组件</a> <a href="/tags/React顶层API/" style="font-size: 10px;">React顶层API</a> <a href="/tags/Redux/" style="font-size: 12.5px;">Redux</a> <a href="/tags/SPA/" style="font-size: 10px;">SPA</a> <a href="/tags/Thunk/" style="font-size: 10px;">Thunk</a> <a href="/tags/action/" style="font-size: 10px;">action</a> <a href="/tags/after伪元素/" style="font-size: 10px;">after伪元素</a> <a href="/tags/alt/" style="font-size: 10px;">alt</a> <a href="/tags/ant-design/" style="font-size: 10px;">ant-design</a> <a href="/tags/async/" style="font-size: 10px;">async</a> <a href="/tags/clearfix/" style="font-size: 10px;">clearfix</a> <a href="/tags/codeSplitting/" style="font-size: 10px;">codeSplitting</a> <a href="/tags/div/" style="font-size: 10px;">div</a> <a href="/tags/div拖拽/" style="font-size: 10px;">div拖拽</a> <a href="/tags/instanceof/" style="font-size: 10px;">instanceof</a> <a href="/tags/meat/" style="font-size: 10px;">meat</a> <a href="/tags/prototype/" style="font-size: 10px;">prototype</a> <a href="/tags/reducer/" style="font-size: 10px;">reducer</a> <a href="/tags/referrer/" style="font-size: 10px;">referrer</a> <a href="/tags/state/" style="font-size: 12.5px;">state</a> <a href="/tags/store/" style="font-size: 10px;">store</a> <a href="/tags/type-file/" style="font-size: 10px;">type=file</a> <a href="/tags/typeof/" style="font-size: 10px;">typeof</a> <a href="/tags/webpack/" style="font-size: 12.5px;">webpack</a> <a href="/tags/事件处理/" style="font-size: 10px;">事件处理</a> <a href="/tags/优化/" style="font-size: 10px;">优化</a> <a href="/tags/优缺点/" style="font-size: 10px;">优缺点</a> <a href="/tags/作用域/" style="font-size: 10px;">作用域</a> <a href="/tags/单页面Web应用/" style="font-size: 10px;">单页面Web应用</a> <a href="/tags/原型链/" style="font-size: 10px;">原型链</a> <a href="/tags/可复用组件/" style="font-size: 10px;">可复用组件</a> <a href="/tags/坐标/" style="font-size: 10px;">坐标</a> <a href="/tags/垃圾回收/" style="font-size: 10px;">垃圾回收</a> <a href="/tags/客户端/" style="font-size: 10px;">客户端</a> <a href="/tags/对象/" style="font-size: 10px;">对象</a> <a href="/tags/异步/" style="font-size: 10px;">异步</a> <a href="/tags/引用类型/" style="font-size: 10px;">引用类型</a> <a href="/tags/执行环境/" style="font-size: 10px;">执行环境</a> <a href="/tags/术语/" style="font-size: 10px;">术语</a> <a href="/tags/样式修改/" style="font-size: 10px;">样式修改</a> <a href="/tags/检测/" style="font-size: 10px;">检测</a> <a href="/tags/清除浮动/" style="font-size: 10px;">清除浮动</a> <a href="/tags/状态/" style="font-size: 10px;">状态</a> <a href="/tags/生命周期/" style="font-size: 12.5px;">生命周期</a> <a href="/tags/类型检测/" style="font-size: 10px;">类型检测</a> <a href="/tags/纯函数/" style="font-size: 10px;">纯函数</a> <a href="/tags/继承/" style="font-size: 10px;">继承</a> <a href="/tags/翻译/" style="font-size: 15px;">翻译</a> <a href="/tags/自动分号插入/" style="font-size: 10px;">自动分号插入</a> <a href="/tags/跨域/" style="font-size: 10px;">跨域</a> <a href="/tags/跨浏览器/" style="font-size: 10px;">跨浏览器</a> <a href="/tags/连续赋值/" style="font-size: 10px;">连续赋值</a> <a href="/tags/遇到的问题/" style="font-size: 10px;">遇到的问题</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">人活着如果没有梦想，那和咸鱼还有什么区别－－－专注于前端, 专注于JavaScript</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">baizn</a></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<a href="/" class="profilepic">
				<img lazy-src="/img/avatar.png" class="js-avatar">
			</a>
			<hgroup>
			  <h1 class="header-author"><a href="/" title="回到主页">baizn</a></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives/">所有文章</a></li>
		        
					<li><a href="/tags/">标签云</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
						<ul class="social">
							
								<li id="Email"><a class="Email" target="_blank" href="/baizhanning@zhubajie.com" title="Email"></a></li>
					        
								<li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/baizn/baizn.github.io" title="GitHub"></a></li>
					        
								<li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
					        
						</ul>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-React生命周期详解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/11/React生命周期详解/" class="article-date">
  	<time datetime="2016-01-11T09:27:44.000Z" itemprop="datePublished">2016-01-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/11/React生命周期详解/">React生命周期详解</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="React_生命周期详解">React 生命周期详解</h2><p>通过react-lifecycle mixin查看组件生命周期的执行顺序。</p>
<p>组件在生命周期的不同状态下的执行顺序</p>
<blockquote>
<ul>
<li><p>首次装载组件时，按顺序执行<strong>getDefaultProps</strong>, <strong>getInitialState</strong>, <strong>componentWillMount</strong>, <strong>render</strong>和<strong>componentDidMount</strong></p>
</li>
<li><p>当卸载组件时，执行<strong>componentWillUnomunt</strong></p>
</li>
<li><p>当重新装载组件时，此时按顺序执行<strong>getInitialState</strong>, <strong>componentWillMount</strong>, <strong>render</strong>,和<strong>componentDidMount</strong>,但不执行<strong>getDefaultProps</strong></p>
</li>
<li><p>当再次渲染组件时，组件接收到更新状态(props改变)，此时按顺序执行<strong>componentWillReceiveProps(state变化时候不会执行该方法)</strong>, <strong>shouldComponentUpdate</strong>, <strong>componentWillUpdate</strong>, <strong>render</strong>和<strong>componentDidUpdate</strong></p>
</li>
</ul>
</blockquote>
<h3 id="自定义组件生命周期">自定义组件生命周期</h3><p>自定义组件生命周期主要通过三种状态进行管理：<strong>MOUNTING</strong>, <strong>RECEIVE_PROPS</strong>, <strong>UNMOUNTING</strong>。它们负责通知组件当前所处状态，应该执行生命周期中的哪些步骤，是否可以更新state。这三个状态对应三个方法：<strong>mountComponent()</strong>, <strong>updateComponent()</strong>, <strong>unmountComponent()</strong>。</p>
<blockquote>
<ul>
<li>mountComponent -&gt; MOUNTING</li>
<li>updateComponent -&gt; RECEIVE_PROPS</li>
<li>unmountComponent -&gt; UNMOUNTING</li>
</ul>
</blockquote>
<h4 id="创建自定义组件">创建自定义组件</h4><p>通过<strong>createClass</strong>创建自定义组件的入口方法，负责管理生命周期中的getDefaultProps。getDefaultProps方法只执行一次，因此所有实例初始化的props将会被共享。</p>
<h3 id="MOUNTING状态">MOUNTING状态</h3><p>mountComponent负责管理生命周期中的<strong>getInitialState()</strong>, <strong>componentWillMount()</strong>, <strong>render()</strong>,和<strong>componentDidMount()</strong>。</p>
<p><strong>getDefaultProps()</strong>是通过Constructor进行管理，因此是整个生命周期中最先执行的方法，在mountComponent中无法调用到getDefaultProps方法。所以<strong>getDefaultProps只执行一次</strong>。</p>
<p><strong>ReactCompositeComponentBase</strong>返回的是一个虚拟节点，因此需要利用<strong>instantiateReactComponent</strong>去得到实例，再使用<strong>mountComponent</strong>拿到结果作为当前自定义元素的结果。</p>
<blockquote>
<ul>
<li><p>通过<strong>mountComponent()</strong>装载组件，此时将状态设置为<strong>MOUNTING</strong>，利用<strong>getInitialState()</strong>获取初始化state，初始化更新队列</p>
</li>
<li><p>如果存在<strong>componentWillMount()</strong>，则执行；如果此时在componentWillMount中调用setState，不会触发<strong>render</strong>，而是进行<strong>state合并</strong></p>
</li>
<li>完成MOUNTING的工作，更新状态为NULL，同时也将执行更新操作，此刻在<strong>render()</strong>中可以获取更新后的<strong>this.state</strong>数据</li>
</ul>
</blockquote>
<p>mountComponent本质上是通过递归渲染内容的，因此父组件的componentWillMount一定在其子组件的componentWillMount之前调用，而父组件的componentDidMount肯定在其子组件的componentDidMount之后调用。</p>
<h3 id="RECEIVE_PROPS状态">RECEIVE_PROPS状态</h3><p><strong>updateComponent()</strong>负责管理生命周期中的<strong>componentWillReceiveProps()</strong>, <strong>shouldComponentUpdate()</strong>, <strong>componentWillUpdate()</strong>, <strong>render()</strong>和<strong>componentDidUpdate()</strong>方法。</p>
<p>通过<strong>updateComponent</strong>更新组件，如果元素前后不一致则需要进行更新组件，此时将状态设置为<strong>RECEIVING_PROPS</strong>。</p>
<p>如果存在<strong>componentWillReceiveProps()</strong>，则执行；如果此时在componentReceiveProps()中调用setState，是不会触发重新render，而是进行state合并。</p>
<p>此时完成了RECEIVING_PROPS的工作，更新状态为NULL，同时state也将执行更新，此刻this.state可以获取到更新后的数据。</p>
<blockquote>
<p>如果在componentWillReceiveProps中调用setState，那么在componentWillReceiveProps, shouldComponentUpdate和componentWillUpdate中还是无法获取到更新后的this.state，此时访问this.state仍然是未更新的数据。只有在render和componentDidUpdate中才能获取到更新后的this.state。</p>
</blockquote>
<p>调用<strong>shouldComponentUpdate()</strong>判断是否需要进行组件更新，如果存在<strong>componentWillUpdate()</strong>则执行。</p>
<p>当渲染完成后，如果存在<strong>componentDidUpdate()</strong>则触发。</p>
<p>updateComponent本质上也是通过递归渲染内容的，因此父组件的componentWillUpdate()一定在其子组件的componentWillUpdate()之前调用；而父组件的componentDidUpdate()一定在其子组件的componentDidUpdate()之后调用。</p>
<p><strong>重要提示：</strong>禁止在shouldComponentUpdate()和componentWillUpdate()中调用setState，这样会造成循环调用。</p>
<h3 id="UNMOUNTING状态">UNMOUNTING状态</h3><p><strong>unmountComponent()</strong>负责管理生命周期中的<strong>componentWillUnmount()</strong>。</p>
<p>首先将状态设置为<strong>UNMOUNTING</strong>，如果存在<strong>componentWillUnmount()</strong>则执行；如果此时在componentWillUnmount()中调用setState，不会触发重新render。更新状态为NULL，完成组件卸载操作。</p>
<h3 id="setState更新机制">setState更新机制</h3><p>当调用setState时，会对state以及_pendingState更新队列进行合并操作，真正更新state的是<strong>replaceState</strong>。</p>
<p><strong>replaceState</strong>会先判断当前状态是否为<strong>MOUNTING</strong>，如果不是即会调用<strong>ReactUpdates.enqueueUpdate()</strong>执行更新。</p>
<p>当状态不为MOUNTING或RECEIVING_PROPS时，<strong>performUpdateIfNecessary</strong>会获取_pendingElement, _pendingState, _pendingForceUpdate, 并调用<strong>updateComponent</strong>进行组件更新。</p>
<blockquote>
<p>如果在shouldComponentUpdate或componentWillUpdate中调用setState，此时的状态已经从RECEIVING_PROPS-&gt;NULL,则performUpdateIfNecessary就会调用updateComponent进行组件更新，但updateComponent又会调用 shouldComponentUpdate和componentWillUpdate，因此造成循环调用，使得浏览器内存被占满后崩溃。</p>
</blockquote>
<h3 id="小结">小结</h3><blockquote>
<ul>
<li>React通过三种状态：MOUNTING, RECEIVE_PROPS, UNMOUNTING管理整个生命周期的执行顺序</li>
<li>setState会先进行_pendingState更新队列的合并操作，不会立即渲染，因此setState是异步操作，且通过判断状态(MOUNTING, RECEIVE_PROPS)来控制渲染的时机</li>
<li>不建议在getDefaultProps, getInitialState, shouldComponentUpdate, componentWillUpdate, render和componentWillUpdate中调用setState，特别不能在shouldComponentUpdate和componentWillUpdate中调用setState，会导致循环调用。</li>
</ul>
</blockquote>
<h3 id="参考资料">参考资料</h3><p><a href="http://web.jobbole.com/84296/" target="_blank" rel="external">React源码系列－生命周期的管理</a></p>

      
      

      <!-- page.path 表示不含根路径的页面网址。还有数种方式可以匹配页面，在此不赘述。 -->
        
    </div>
    
    <div class="article-info article-info-index">
      
      

      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/生命周期/">生命周期</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>










  
    <article id="post-JavaScript连续赋值" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/11/JavaScript连续赋值/" class="article-date">
  	<time datetime="2016-01-11T09:25:08.000Z" itemprop="datePublished">2016-01-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/11/JavaScript连续赋值/">JavaScript连续赋值</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##JavaScript连续赋值<br>先看一段简单的代码：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="keyword">n</span>: 1&#125;;</span><br><span class="line">a.x = a = &#123;<span class="keyword">n</span>: 2&#125;;</span><br><span class="line">console.<span class="literal">log</span>(a.x);</span><br></pre></td></tr></table></figure>
<p>上面的代码会打印出什么内容呢？// undefined</p>
<p>再看下面这段代码：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="keyword">n</span>: 1&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a.x = a = &#123;<span class="keyword">n</span>: 2&#125;;</span><br><span class="line">console.<span class="literal">log</span>(b.x, a.x);</span><br></pre></td></tr></table></figure>
<p>上面这段代码又会打印出什么内容呢？</p>
<p>不卖关子，直接上答案：</p>
<blockquote>
<p>第一部分代码会打印出： undefined;</p>
<p>第二部分代码会打印出：Object {n: 2}, undefined</p>
</blockquote>
<p>实际的执行过程：从右到左赋值，a被赋值为{n: 2}，接着a.x被赋值为{n: 2}。这里很重要的一点就是：a = {n: 2}中的a指向的是对象{n: 2}，而a.x={n: 2}中的a指向的是原对象{n: 1}。</p>

      
      

      <!-- page.path 表示不含根路径的页面网址。还有数种方式可以匹配页面，在此不赘述。 -->
        
    </div>
    
    <div class="article-info article-info-index">
      
      

      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/连续赋值/">连续赋值</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>










  
    <article id="post-详解CSS之浮动" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/11/详解CSS之浮动/" class="article-date">
  	<time datetime="2015-12-11T04:15:55.000Z" itemprop="datePublished">2015-12-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/11/详解CSS之浮动/">详解CSS之浮动</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="详解CSS之浮动">详解CSS之浮动</h2><h3 id="浮动带来的缺陷">浮动带来的缺陷</h3><blockquote>
<ul>
<li>元素设置浮动后，会影响它的兄弟元素</li>
<li>浮动的元素脱离了文档流（仍在文档流中），包含它的父元素不会因为这个浮动元素的存在而自动撑高，这样就会造成父元素高度塌陷的问题</li>
</ul>
</blockquote>
<h3 id="清除浮动常见的方法">清除浮动常见的方法</h3><p>在受影响的兄弟元素上设置clear:both;属性后，不会跟浮动元素同行，而是占据一整行，也不是根据内容自动调整宽度。</p>
<p>clear的原理：clear会为元素添加足够的空白空间，使得该元素的位置会放置在它之前得一个浮动元素之下，这跟增加元素外边距使得元素占据满行而强制换行得效果是一样得。</p>
<p>使用在受影响的兄弟元素上设置clear:both;属性得方法后，只是清除了浮动元素对兄弟元素得影响，并没有解决父元素高度塌陷得问题，因此，我们需要更高级得清除浮动：<strong>闭合浮动</strong>。</p>
<h4 id="空div方法">空div方法</h4><p>在浮动元素后面添加:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.clearfix &#123;</span><br><span class="line">	clear:both;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"clearfix"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<h4 id="overflow方法">overflow方法</h4><p>在浮动元素得父元素上设置overflow得值为hidden或auto，可以闭合浮动。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.clearfix &#123;</span><br><span class="line">	overflow: hidden;</span><br><span class="line">	*zoom: <span class="number">1</span>; <span class="comment">//IE6中触发hasLayout</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">"clearfix"</span>&gt;</span><br><span class="line">	&lt;div <span class="keyword">class</span>=<span class="string">"left"</span>&gt;<span class="keyword">float</span> left&lt;/div&gt;</span><br><span class="line">	&lt;div <span class="keyword">class</span>=<span class="string">"left"</span>&gt;left&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>使用overflow可能产生得问题：当元素内包括会超出父元素边界的子元素时，可能会覆盖掉有用的子元素，或是产生多余的滚动条。</p>
<h4 id="使用:after伪元素的方法">使用:after伪元素的方法</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.clearfix &#123;</span><br><span class="line">	*zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:<span class="keyword">after</span> &#123;</span><br><span class="line">	content: '',</span><br><span class="line">	display: block;</span><br><span class="line">	height: <span class="number">0</span>,</span><br><span class="line">	clear: both;</span><br><span class="line">	visibility: hidden;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"box clearfix"</span>&gt;</span><br><span class="line">	&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"main left"</span>&gt;left1&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">	&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"foot left"</span>&gt;left2&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="清除浮动方法的实质——CSS_Clear与BFC特性">清除浮动方法的实质——CSS Clear与BFC特性</h3><blockquote>
<ul>
<li>利用clear属性：包括在浮动元素尾部添加一个带有clear:both属性的空div来闭合元素，其实利用:after伪元素方法也是在元素尾部添加一个内容为空白字符并带有clear:both属性的元素的实现的</li>
<li>触发浮动元素父元素的BFC，使得该父元素可以包含浮动元素</li>
</ul>
</blockquote>
<h3 id="参考资料">参考资料</h3><p><a href="http://kayosite.com/remove-floating-style-in-detail.html" target="_blank" rel="external">详说清除浮动</a></p>

      
      

      <!-- page.path 表示不含根路径的页面网址。还有数种方式可以匹配页面，在此不赘述。 -->
        
    </div>
    
    <div class="article-info article-info-index">
      
      

      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/">CSS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Float/">Float</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/after伪元素/">after伪元素</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/clearfix/">clearfix</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/清除浮动/">清除浮动</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>










  
    <article id="post-详解CSS之BFC" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/11/详解CSS之BFC/" class="article-date">
  	<time datetime="2015-12-11T03:18:32.000Z" itemprop="datePublished">2015-12-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/11/详解CSS之BFC/">详解CSS之BFC</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="详解CSS之BFC">详解CSS之BFC</h2><h3 id="什么是BFC">什么是BFC</h3><p>W3C中对BFC的定义</p>
<blockquote>
<p>Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with ‘overflow’ other than ‘visible’ (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.</p>
</blockquote>
<p>简单翻译出来就是：浮动元素，绝对定位元素和块级容器（比如inline-blocks, table-cells和table-captions）非块级盒子，以及overflow不为visible（除过当该值已经传递到了viewport）的块级盒子，都会给它们的内容创建新的块状格式化上下文，即传说中的<strong>BFC</strong>。</p>
<p>通俗的理解就是：BFC中元素布局不受外界的影响，并且在一个BFC中，块级盒子和行级盒子都会垂直沿着其父元素的边框排列。利用BFC特性可以消除浮动元素对其非浮动同级元素和子元素的影响。从功能上看，BFC可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素。</p>
<p>BFC就是一种属性，这种属性会影响元素的定位以及与其兄弟元素之间的相互作用。</p>
<h3 id="如何触发BFC">如何触发BFC</h3><blockquote>
<ul>
<li>浮动元素：float除none以外的值</li>
<li>绝对定位元素：position值为absolute或fixed</li>
<li>display值为以下之一：inline-block, table-cells, table-captions</li>
<li>overflow除了visible以外的值（hidden，auto，scroll）</li>
</ul>
</blockquote>
<h3 id="BFC的特性">BFC的特性</h3><blockquote>
<p>BFC会阻止外边距折叠</p>
</blockquote>
<p>两个相邻的div在垂直方向上的外边距会发生折叠，但我们布局时候如果不需要外边距折叠，则可以利用BFC的阻止外边距特性。</p>
<blockquote>
<p>BFC可以包含浮动元素</p>
</blockquote>
<p>BFC会根据子元素的情况自动适应高度，即使其子元素中包括浮动元素。</p>
<blockquote>
<p>BFC可以阻止元素被浮动元素覆盖</p>
</blockquote>
<p>浮动元素的块状兄弟元素会无视浮动元素的位置，尽量占满一整行，这样就会被浮动元素覆盖，为该兄弟元素触发BFC后可以阻止这种情况发生。</p>
<h3 id="合并外边距与BFC">合并外边距与BFC</h3><p>CSS中，相邻的两个盒子（同级或包含关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被成为折叠，合并以后新的外边距被成为折叠外边距。</p>
<h4 id="外边距折叠时遵循的原则">外边距折叠时遵循的原则</h4><blockquote>
<ul>
<li>两个相邻的外边距都是正数，折叠结果取两者较大的值</li>
<li>两个相邻外边距都是负数，折叠结果取两者绝对值较大的值（即取小的值）</li>
<li>两个相邻外边距一正一负，折叠结果是两者相加的和</li>
</ul>
</blockquote>
<p>外边距折叠的必备条件：<strong>margin必须是相邻的。</strong></p>
<p>根据W3C规范，两个margin是相邻的必须满足一下条件。</p>
<blockquote>
<ul>
<li>必须是常规文档流（非float和非absolute）的块级盒子，并且处于同一个BFC中</li>
<li>没有线盒，没有空隙，没有padding和border将它们分割开</li>
<li><p>都属于垂直方向上相邻的外边距</p>
</li>
<li><p>元素的margin-top与其第一个常规文档流的子元素的margin-top</p>
</li>
<li>元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top</li>
<li>height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom</li>
<li>高度为0，最小高度为0，不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的margin-top和margin-bottom</li>
</ul>
</blockquote>
<p>由以上条件可知：<strong>创建了BFC的元素不会和其相邻的元素的外边距折叠。</strong></p>
<h3 id="参考资料">参考资料</h3><p>1: <a href="http://kayosite.com/block-formatting-contexts-in-detail.html" target="_blank" rel="external">详说BFC</a></p>

      
      

      <!-- page.path 表示不含根路径的页面网址。还有数种方式可以匹配页面，在此不赘述。 -->
        
    </div>
    
    <div class="article-info article-info-index">
      
      

      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BFC/">BFC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/">CSS</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>










  
    <article id="post-使用JavaScript修改文件选择框样式" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/29/使用JavaScript修改文件选择框样式/" class="article-date">
  	<time datetime="2015-11-29T09:34:14.000Z" itemprop="datePublished">2015-11-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/29/使用JavaScript修改文件选择框样式/">使用JavaScript修改文件选择框样式</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="使用JavaScript修改文本框的样式">使用JavaScript修改文本框的样式</h3><p>当上传文件时，默认的文本框样式直接丑到哭，可以使用JS进行自定义样式。基本步骤如下：</p>
<blockquote>
<ul>
<li>隐藏掉type=file的输入框</li>
<li>自定义控件样式</li>
<li>定义事件，当点击自定义控件时，调用隐藏的输入框click事件</li>
</ul>
</blockquote>
<p>基本代码框架如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="class"><span class="keyword">type</span>=</span><span class="symbol">'fil</span>e' name=<span class="symbol">'fil</span>e' id=<span class="symbol">'fil</span>e' style=<span class="symbol">'display</span>: none;' /&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span>=</span><span class="symbol">'selfstyl</span>e'&gt;</span><br><span class="line">	&lt;input <span class="class"><span class="keyword">type</span>=</span><span class="symbol">'tex</span>t' id=<span class="symbol">'showur</span>l' <span class="class"><span class="keyword">class</span>=</span><span class="symbol">'inputstyl</span>e' disabled /&gt;</span><br><span class="line">	&lt;a <span class="class"><span class="keyword">class</span>=</span><span class="symbol">'btn</span> btn-info' id=<span class="symbol">'triggerFil</span>e'&gt;</span><br><span class="line">		&lt;i <span class="class"><span class="keyword">class</span>=</span><span class="symbol">'icon</span>-folder-open-alt'&gt;&lt;/i&gt;浏览</span><br><span class="line">	&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">$('#file').change(function() &#123;</span><br><span class="line">	<span class="keyword">var</span> path = $(<span class="keyword">this</span>).<span class="keyword">val</span>();</span><br><span class="line">	path = path.split('\\');</span><br><span class="line">	path = path[path.length - <span class="number">1</span>];</span><br><span class="line">	$('#showurl').<span class="keyword">val</span>(path);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

      
      

      <!-- page.path 表示不含根路径的页面网址。还有数种方式可以匹配页面，在此不赘述。 -->
        
    </div>
    
    <div class="article-info article-info-index">
      
      

      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/type-file/">type=file</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/样式修改/">样式修改</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>










  
    <article id="post-JavaScript检测客户端" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/27/JavaScript检测客户端/" class="article-date">
  	<time datetime="2015-11-27T04:22:43.000Z" itemprop="datePublished">2015-11-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/27/JavaScript检测客户端/">JavaScript检测客户端</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="使用JavaScript检测客户端">使用JavaScript检测客户端</h2><h3 id="能力检测">能力检测</h3><p>能力检测又称特性检测。能力检测的目的不是识别具体的浏览器，而是识别浏览器的能力。</p>
<p>能力检测的基本模式如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="class"><span class="keyword">object</span>.<span class="title">property</span>) &#123;</span></span><br><span class="line">	<span class="comment">//存在该属性或方法，使用object.property</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用能力检测要注意一下两点：</p>
<blockquote>
<ul>
<li>先检测达成目的的最常用的特性</li>
<li>必须测试实际要用到的特性</li>
</ul>
</blockquote>
<p>在可能的情况下，尽量使用typeof进行能力检测。但各个浏览器队typeof的返回值又不尽相同，可以采用下面的代码进行检测。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function isHostMethod(<span class="class"><span class="keyword">object</span>, <span class="title">property</span>) &#123;</span></span><br><span class="line">	<span class="keyword">var</span> tp = typeof <span class="class"><span class="keyword">object</span>[</span>property];</span><br><span class="line">	<span class="keyword">return</span> tp === <span class="symbol">'functio</span>n' ||</span><br><span class="line">		(!!(tp === <span class="symbol">'objec</span>t' &amp;&amp; <span class="class"><span class="keyword">object</span>[</span>property])) ||</span><br><span class="line">		t === <span class="symbol">'unknow</span>n';</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果知道应用程序需要使用某些特定的浏览器特性，那么最好是一次性检测所有相关的特性，而不要分别检测。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//确定浏览器是否支持Netscape风格的插件</span></span><br><span class="line"><span class="keyword">var</span> hasNSPlugins = !!(navigator.plugins &amp;&amp; navigator.plugins.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">//确认浏览器是否具有DOM1级规定的能力</span></span><br><span class="line"><span class="keyword">var</span> hasDOM1 = !!(<span class="built_in">document</span>.getElementById &amp;&amp; <span class="built_in">document</span>.createElement &amp;&amp; <span class="built_in">document</span>.getElementByTagName);</span><br></pre></td></tr></table></figure>
<h3 id="用户代理检测">用户代理检测</h3><p>用户代理检测通过检测用户代理字符串确定实际使用的浏览器。该字符串在javascript中可以通过navigator.userAgent属性访问。</p>
<h4 id="用户代理字符串检测技术">用户代理字符串检测技术</h4><p>使用用户代理字符串来检测特定浏览器，一般情况下知道呈现引擎和最低限度的版本就可以决定正确的操作方法。</p>
<p><strong>识别呈现引擎</strong></p>
<p>知道确切的浏览器名字和版本号不如确切知道它使用的什么呈现引擎。如果Firefox，Camino和Netscape都使用相同版本的Gecko，那它们肯定支持相同的特性。因此，可以编写脚本检测5大呈现引擎：IE，Gecko，WebKit，KHTML和Opera。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> clientCheck = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> engine = &#123;</span><br><span class="line">		ie: <span class="number">0</span>,</span><br><span class="line">		gecko: <span class="number">0</span>,</span><br><span class="line">		webkit: <span class="number">0</span>,</span><br><span class="line">		khtml: <span class="number">0</span>,</span><br><span class="line">		opera: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//具体版本号</span></span><br><span class="line">		version: <span class="literal">null</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		engine: engine</span><br><span class="line">	&#125;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p><strong>识别浏览器</strong></p>
<p>大多数情况下，识别了浏览器的呈现引擎就可以为我们采取正确的操作提供依据了。但只有呈现引擎还不能说明存在所需的JavaScript功能。</p>
<p>因此，还需要在上面代码的基础中加入一下部分代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var browser = &#123;</span><br><span class="line">	ie: <span class="number">0</span>,</span><br><span class="line">	firefox: <span class="number">0</span>,</span><br><span class="line">	safari: <span class="number">0</span>,</span><br><span class="line">	konq: <span class="number">0</span>,</span><br><span class="line">	opera: <span class="number">0</span>,</span><br><span class="line">	chrome: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">	version: null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">	engine: engine,</span><br><span class="line">	browser: browser</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>识别平台</strong></p>
<p>很多时候，只要知道呈现引擎就足以编写适当的代码了。但在某些条件下，平台可能是必须关注的问题，那些具有各种平台版本的浏览器在不同平台下可能会有不同的问题。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">system</span> = &#123;</span><br><span class="line">	win: <span class="constant">false</span>,</span><br><span class="line">	mac: <span class="constant">false</span>,</span><br><span class="line">	unix: <span class="constant">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="constant">return</span> &#123;</span><br><span class="line">	engine: engine,</span><br><span class="line">	browser: browser,</span><br><span class="line">	<span class="keyword">system</span>: <span class="keyword">system</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>识别Window平台</strong></p>
<p>在Windows平台下，还可以通过用户代理字符串中进一步取得具体的操作系统信息。</p>
<p>使用下面的正则表达式匹配各个Windows版本：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">Win</span>(?:dows)?([^<span class="keyword">do</span>]&#123;2&#125;)\s?(\<span class="keyword">d</span>+\.\<span class="keyword">d</span>+)?/</span><br></pre></td></tr></table></figure>
<p><strong>识别移动设备</strong></p>
<p>添加所有移动设备属性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> system</span> = &#123;</span><br><span class="line">	<span class="comment">//移动设备</span></span><br><span class="line">	iphone: <span class="literal">false</span>,</span><br><span class="line">	ipod: <span class="literal">false</span>,</span><br><span class="line">	ipad: <span class="literal">false</span>,</span><br><span class="line">	ios: <span class="literal">false</span>,</span><br><span class="line">	android: <span class="literal">false</span>,</span><br><span class="line">	nokiaN: <span class="literal">false</span>,</span><br><span class="line">	winMobile: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检测IOS版本：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">va ua = navigator.userAgent;</span><br><span class="line"><span class="keyword">if</span>(system.mac &amp;&amp; ua.indexOf(<span class="string">'Mobile'</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">	if(/CPU (?:iPhone)?OS (\d+<span class="number">_</span>\d+)/.test(ua)) &#123;</span><br><span class="line">		system.ios = parseFloat(RegExp.<span class="variable">$1</span>.replace(<span class="string">'_'</span>, <span class="string">'.'</span>));</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		system.ios = <span class="number">2</span>; // 默认</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>识别游戏系统</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> system = &#123;</span><br><span class="line">	wii: <span class="literal">false</span>,</span><br><span class="line">	ps: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system.wii = ua.indexOf(<span class="string">'Wii'</span>) &gt; -<span class="number">1</span>;</span><br><span class="line">system.ps = <span class="regexp">/playstation/i</span>.test(ua);</span><br></pre></td></tr></table></figure>
<p>上面简单介绍了检测呈现引擎、浏览器、平台及移动设备等的基本思路，完整的检测呈现引擎、浏览器、平台、Window操作系统、移动设备和游戏系统的代码请猛戳<a href="https://github.com/baizn/client-detecting/blob/master/clientDetecting.js" target="_blank" rel="external">这里</a>。</p>

      
      

      <!-- page.path 表示不含根路径的页面网址。还有数种方式可以匹配页面，在此不赘述。 -->
        
    </div>
    
    <div class="article-info article-info-index">
      
      

      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/客户端/">客户端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/检测/">检测</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>










  
    <article id="post-JavaScript继承" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/20/JavaScript继承/" class="article-date">
  	<time datetime="2015-11-20T08:57:23.000Z" itemprop="datePublished">2015-11-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/20/JavaScript继承/">JavaScript继承</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JavaScript继承">JavaScript继承</h2><p>许多面向对象语言都支持接口继承和实现继承。接口继承只继承方法签名，实现继承则继承实际的方法。由于函数没有签名，所以ECMAScript只支持实现继承，主要是依靠原型链来实现。</p>
<h3 id="原型链">原型链</h3><p>实现原型链的基本模式。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getFlag = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Children</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.cFlag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承Parent</span></span><br><span class="line">Children.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line">Children.prototype.getCflag = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.cFlag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Children();</span><br><span class="line">instance.flag; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>原来存在与Parent中的所有属性和方法，现在也存在于Children.prototype中了。Children的原型指向了另外一个对象————Parent的原型，而这个原型对象的constructor属性指向的是Parent。</p>
<p><strong>所有的引用类型默认都继承了Object，而这个继承也是通过原型链实现的。</strong></p>
<p>可以通过以下两种方法来确定原型和实例之间的关系。</p>
<blockquote>
<ul>
<li>instanceof操作符</li>
<li>isPrototypeOf()方法</li>
</ul>
</blockquote>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">instance instanceof Object; // true<span class="instruction"></span><br><span class="line">instance </span>instanceof Parent; // true<span class="instruction"></span><br><span class="line">instance </span>instanceof Children; // true</span><br><span class="line"></span><br><span class="line">Object.prototype.isPropertyOf(instance<span class="function">)</span>; // true</span><br><span class="line">Parent.prototype.isPropertyOf(instance<span class="function">)</span>; // true</span><br><span class="line">Children.prototype.isPropertyOf(instance<span class="function">)</span>; // true</span><br></pre></td></tr></table></figure>
<p>给原型添加方法的代码一定要放在替换原型的语句之后。</p>
<p><strong>重点提醒：</strong>通过原型链实现继承时，不能使用对象字面量创建原型方法，因为这样会重写原型链。</p>
<p>原型链存在的问题：</p>
<blockquote>
<ul>
<li>原型包含引用类型的值，会被所有实例共享</li>
<li>创建子类型的实例时，不能向父类的构造函数中传递参数</li>
</ul>
</blockquote>
<h3 id="借用构造函数">借用构造函数</h3><p>基本思路：在子类型构造函数的内部调用父类的构造函数。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//继承Parent</span></span><br><span class="line">	Parent.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c1 = <span class="keyword">new</span> Child();</span><br><span class="line">c1.colors.push(<span class="string">'green'</span>);</span><br><span class="line"></span><br><span class="line">c1.colors; <span class="comment">// red, blue, green</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c2 = <span class="keyword">new</span> Child();</span><br><span class="line">c2.colors; <span class="comment">// red, blue</span></span><br></pre></td></tr></table></figure>
<p>相比原型链而言，借用构造函数有一个很大的优势：<strong>可以在子类型的构造函数中向父类构造函数传递参数</strong>。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//继承Parent</span></span><br><span class="line">	Parent.call(<span class="keyword">this</span>, <span class="string">'bzn'</span>);</span><br><span class="line">	<span class="keyword">this</span>.age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c1 = <span class="keyword">new</span> Child();</span><br><span class="line">c1.name; <span class="comment">// bzn</span></span><br><span class="line">c1.age;  <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p><strong>借用构造函数存在的问题：</strong>方法都要在构造函数中定义，因此做不到函数复用。</p>
<h3 id="组合继承（原型链和构造函数）">组合继承（原型链和构造函数）</h3><p>基本思路：使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span><span class="params">(name, age)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//继承Parent</span></span><br><span class="line">	Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"></span><br><span class="line">Child.prototype.getAge = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c1 = <span class="keyword">new</span> Child(<span class="string">'bzn'</span>, <span class="number">20</span>);</span><br><span class="line">c1.colors.push(<span class="string">'green'</span>);</span><br><span class="line">c1.colors; <span class="comment">// red, blue, green ==&gt; Parent</span></span><br><span class="line">c1.name; <span class="comment">// bzn ==&gt; Parent</span></span><br><span class="line">c1.age; <span class="comment">// 20 ==&gt; Child</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c2 = <span class="keyword">new</span> Child(<span class="string">'baizn'</span>, <span class="number">21</span>);</span><br><span class="line">c2.colors; <span class="comment">// red, blue</span></span><br></pre></td></tr></table></figure>
<p>组合继承的问题：</p>
<blockquote>
<p>无论什么情况下，都会调用两次父类的构造函数。一次是在创建子类型原型的时候，另一次是在子类型构造函数内部</p>
</blockquote>
<h3 id="原型式继承">原型式继承</h3><p>基本思路：借助原型可以基于已有对象创建新对象，同时还不必创建自定义类型。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject</span><span class="params">(o)</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	F.prototype = o;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createObject对传入的对象执行了一次浅复制。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	name: <span class="string">'bzn'</span>,</span><br><span class="line">	colors: [<span class="string">'red'</span>, <span class="string">'blue'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = createObject(person);</span><br><span class="line">p1.name = <span class="string">'baizn'</span>;</span><br><span class="line">p1.colors.push(<span class="string">'green'</span>);</span><br><span class="line">p1.colors; <span class="comment">// red, blue, green</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = createObject(person);</span><br><span class="line">p2.colors.push(<span class="string">'rt'</span>);</span><br><span class="line">p2.colors; <span class="comment">// red, blue, green, rt</span></span><br></pre></td></tr></table></figure>
<p>ECMAScript5新增了Object.create()方法，该方法接收两个参数：一个用作新对象原型的对象和一个为新对象定义属性的对象（可选）。当传入一个参数时候，Object.create()和createObject()方法行为一致。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	name: <span class="string">'bzn'</span>,</span><br><span class="line">	colors: [<span class="string">'red'</span>, <span class="string">'blue'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Object</span>.create(person);</span><br><span class="line">p1.colors.push(<span class="string">'green'</span>);</span><br><span class="line">p1.colors; <span class="comment">// red, blue, green</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Object</span>.create(person);</span><br><span class="line">p2.colors.push(<span class="string">'rb'</span>);</span><br><span class="line">p2.colors; <span class="comment">// red, blue, green, rb</span></span><br></pre></td></tr></table></figure>
<p>Object.create()的第二个参数与Object.defineProperties()方法的第二个参数格式相同，每个属性都式通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p3 = Object.create(person, &#123;</span><br><span class="line">	name: &#123;</span><br><span class="line">		<span class="keyword">value</span>: <span class="string">'baizn'</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">p3.name; <span class="comment">// baizn</span></span><br></pre></td></tr></table></figure>
<h3 id="寄生式继承">寄生式继承</h3><p>基本思路：创建一个仅用于封装继承过程的函数，该函数内部以某种方式来增强对象，最后返回对象。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span><span class="params">(o)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> <span class="keyword">clone</span> = Object.create(o); <span class="comment">//创建一个新对象</span></span><br><span class="line">	<span class="keyword">clone</span>.say = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		console.log(<span class="string">'hello'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">clone</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	name: <span class="string">'bzn'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = createObj(person);</span><br><span class="line">p1.say(); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
<p>基于person对象返回新对象p1，新对象不仅具有person的所有属性和方法，而且还有自己定义的say方法。</p>
<h3 id="寄生组合继承">寄生组合继承</h3><p>基本思路：借用构造函数来继承属性，通过原型链的混成形式来继承方法。即不必为指定子类型的原型而调用父类的构造函数，只需父类原型的一个副本而已。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> o = <span class="built_in">Object</span>.create(parent.prototype); <span class="comment">// 创建对象</span></span><br><span class="line">	o.constructor = child; <span class="comment">// 增强对象</span></span><br><span class="line">	child.prototype = o; <span class="comment">// 指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本步骤如下。</p>
<blockquote>
<ul>
<li>创建父类原型的一个副本</li>
<li>为创建的副本添加constructor属性，弥补因重写原型而失去的默认的constructor属性</li>
<li>将新创建的对象（副本）赋值给子类型的原型</li>
</ul>
</blockquote>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.colors = [<span class="string">'red'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span><span class="params">(name, age)</span> </span>&#123;</span><br><span class="line">	Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(Child, Parent);</span><br><span class="line"></span><br><span class="line">Child.prototype.getAge = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>寄生组合继承模式的优点：</p>
<blockquote>
<ul>
<li>只调用一次父类构造函数</li>
<li>原型链保存不变</li>
<li>能够正常使用instanceof和isPropertyOf()</li>
</ul>
</blockquote>

      
      

      <!-- page.path 表示不含根路径的页面网址。还有数种方式可以匹配页面，在此不赘述。 -->
        
    </div>
    
    <div class="article-info article-info-index">
      
      

      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/prototype/">prototype</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原型链/">原型链</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/继承/">继承</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>










  
    <article id="post-JavaScript对象" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/20/JavaScript对象/" class="article-date">
  	<time datetime="2015-11-20T06:59:34.000Z" itemprop="datePublished">2015-11-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/20/JavaScript对象/">JavaScript对象</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JavaScript对象">JavaScript对象</h2><h3 id="对象属性">对象属性</h3><h4 id="属性类型">属性类型</h4><p>ECMAScript中有两种属性：数据属性和访问器属性。</p>
<p><strong>数据属性</strong></p>
<p>数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。</p>
<blockquote>
<ul>
<li>[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性。默认值位true</li>
<li>[[Enumerable]]：表示能否通过for-in循环返回属性。默认值为true</li>
<li>[[Value]]：包含这个属性的数据值。读取属性值的时候从这个位置读取；写入属性值的时候，把新值保存在这个位置。默认值为undefined</li>
<li>[[Writable]]：表示能否修改属性的值。默认值为true</li>
</ul>
</blockquote>
<p>修改属性默认的特性，可以使用ECMAScript的Object.defineProperty()方法。该方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'name'</span>, &#123;</span><br><span class="line">	writable: <span class="literal">false</span>,</span><br><span class="line">	configurable: <span class="literal">false</span>,</span><br><span class="line">	value: <span class="string">'Baizn'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">person.name; <span class="comment">// Baizn;</span></span><br><span class="line">person.name = <span class="string">'213'</span>;</span><br><span class="line">person.name; <span class="comment">// Baizn</span></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line">person.name; <span class="comment">// Baizn</span></span><br></pre></td></tr></table></figure>
<p>上面的代码，在严格模式下会抛出错误。而且，如果把属性定义为不可配置的，就不能再把它变回可配置了。再调用Object.defineProperty()方法修改除writable之外的特性，都会导致错误。</p>
<p>在调用Object.defineProperty()方法时，如果不指定，configurable, enumerable和writable特性的默认值都为false。</p>
<p><strong>访问器属性</strong></p>
<p>访问器属性不包含数据值，它们包含一对getter和setter函数。访问器属性有如下4个特性：</p>
<blockquote>
<ul>
<li>[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性，对于直接在对象上定义的属性，默认为true</li>
<li>[[Enumerable]]：表示能否通过for-in循环返回属性，对于直接在对象上定义的属性，默认为true</li>
<li>[[Get]]：在读取属性时调用的函数，默认为undefined</li>
<li>[[Set]]：在写入属性时调用的函数，默认为undefined</li>
</ul>
</blockquote>
<p>访问器属性不能直接定义，必须使用Object.defineProperty()来定义。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">	year: <span class="number">2015</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(book, <span class="string">'y'</span>, &#123;</span><br><span class="line">	<span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.year;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="keyword">set</span>: <span class="function"><span class="keyword">function</span><span class="params">(year)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.year = year;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">book.year = <span class="number">2015</span>;</span><br></pre></td></tr></table></figure>
<h4 id="定义多个属性">定义多个属性</h4><p>ECMAScript5定义了Object.defineProperties()方法。利用这个方法可以通过描述符一次定义多个属性。接收两个对象参数：第一个是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;;</span><br><span class="line">Object.defineProperties(book, &#123;</span><br><span class="line">	_year: &#123;</span><br><span class="line">		value: <span class="number">2015</span></span><br><span class="line">	&#125;,</span><br><span class="line">	edition: &#123;</span><br><span class="line">		value: <span class="number">1</span></span><br><span class="line">	&#125;,</span><br><span class="line">	year: &#123;</span><br><span class="line">		<span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="keyword">set</span>: <span class="function"><span class="keyword">function</span><span class="params">(value)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>._year = value;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="读取属性的特性">读取属性的特性</h4><p>使用ECMAScript的Object.getOwnPropertyDescriptor()方法，可以获取到给定属性的描述符。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> descriptor = Object.getOwnPropertyDescriptor(book, <span class="string">'_year'</span>);</span><br><span class="line">descriptor.<span class="keyword">value</span>; <span class="comment">// 2015</span></span><br><span class="line">descriptor.configurable; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">typeof</span> descriptor.<span class="keyword">get</span>; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="创建对象">创建对象</h3><p>使用Object构造函数或对象字面量都可以用来创建单个对象，但当在一个接口中创建很多对象时，会产生大量重复的代码。</p>
<h4 id="工厂模式">工厂模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">	o.name = name;</span><br><span class="line">	o.age = age;</span><br><span class="line">	o.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = createPerson(<span class="string">'baizn'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = createPerson(<span class="string">'xiao'</span>, <span class="number">19</span>);</span><br></pre></td></tr></table></figure>
<p>工厂模式虽然解决了多个相似对象的问题，但却没有解决对象识别的问题（即如何知道一个对象的类型）。</p>
<h4 id="构造函数模式">构造函数模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'baizn'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'xiao'</span>, <span class="number">19</span>);</span><br></pre></td></tr></table></figure>
<p>和工厂模式相比，有以下不同之处：</p>
<blockquote>
<ul>
<li>没有显示地创建对象</li>
<li>直接将属性和方法赋值给了this对象</li>
<li>没有return语句</li>
</ul>
</blockquote>
<p>创建一个新的实例，会经过以下4步：</p>
<blockquote>
<ul>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象（this就指向了这个新对象）</li>
<li>执行构造函数中的代码（添加新属性）</li>
<li>返回新对象</li>
</ul>
</blockquote>
<p>上面的代码中，p1和p2分别保存Person的不同实例，这两个对象都有一个constructor属性，该属性指向Person。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1.constructor == <span class="constant">Person</span>; <span class="regexp">//</span> <span class="literal">true</span></span><br><span class="line">p2.constructor == <span class="constant">Person</span>; <span class="regexp">//</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>对象的constructor属性最初是用来标识对象类型的。检测对象类型时候，建议使用<strong>instanceof</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line">p1 <span class="keyword">instanceof</span> Person; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong>将构造函数当作普通函数</strong></p>
<p>构造函数与普通函数的唯一区别就是调用方式不同。任何函数，只要通过new操作符来调用，那它就可以作为构造函数。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'bzn'</span>, <span class="number">18</span>);</span><br><span class="line">person.getName(); <span class="comment">// bzn</span></span><br><span class="line"></span><br><span class="line">Person(<span class="string">'bzn'</span>, <span class="number">19</span>);</span><br><span class="line"><span class="built_in">window</span>.getName(); <span class="comment">// bzn</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Person.call(o, <span class="string">'bzn'</span>, <span class="number">19</span>);</span><br><span class="line">o.getName(); <span class="comment">// bzn</span></span><br></pre></td></tr></table></figure>
<h4 id="原型模式">原型模式</h4><p>创建的每个函数都有一个prototype属性，该属性是一个指针，指向一个对象，这个对象的作用是包含可以由特定类型的所有实例共享的属性和方法。使用原型对象的好处是<strong>可以让所有多想实例共享它所包含的属性和方法</strong>。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">()</span> <span class="comment">&#123;&#125;</span></span><br><span class="line"><span class="title">Person</span>.<span class="title">prototype</span>.<span class="title">name</span> = '<span class="title">baizn</span>;</span></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span><span class="params">()</span> <span class="comment">&#123;</span><br><span class="line">	console.log(this.name);</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="title">var</span> <span class="title">p1</span> = <span class="title">new</span> <span class="title">Person</span><span class="params">()</span>;</span></span><br><span class="line">p1.getName(); <span class="comment">// baizn</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">p1.getName == p2.getName(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong>原型对象</strong></p>
<p>只要创建一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获取一个constructor属性，这个属性包含一个指向prototype属性所在函数的指针。</p>
<p>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性[[Prototype]]），指向构造函数的原型对象。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Person</span>.prototype ==&gt; <span class="keyword">Person</span> Prototype</span><br><span class="line"><span class="keyword">Person</span>.prototype.constuctor ==&gt; <span class="keyword">Person</span>;</span><br><span class="line">p1.<span class="comment">[<span class="comment">[Prototype]</span>]</span> ==&gt; <span class="keyword">Person</span>.prototype;</span><br></pre></td></tr></table></figure>
<p>使用isPrototypeOf()方法来确定[[Prototype]]指向Person.prototype。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">Person</span>.prototype.isPropertyOf(p1); <span class="regexp">//</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>ECMAScript5新增了<strong>Object.getPropertyOf()</strong>方法，返回[[Prototype]]的值。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPropertyOf(p1); <span class="comment">// Person.prototype</span></span><br><span class="line"><span class="built_in">Object</span>.getPropertyOf(p1).name; <span class="comment">// baizn</span></span><br></pre></td></tr></table></figure>
<p>如果实例中定义了和原型中同名的属性名，则原型中的属性会被覆盖。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'baizn'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">p1.name = <span class="string">'bzn'</span>;</span><br><span class="line">p1.name; <span class="comment">// bzn; ==&gt; 实例</span></span><br><span class="line">p2.name; <span class="comment">// baizn ==&gt;  原型</span></span><br></pre></td></tr></table></figure>
<p>使用<strong>hasOwnProperty()</strong>方法可以检测一个属性是存在于实例中还是存在原型中，当属性只存在于对象实例中时，返回true。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'baizn'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">p1.hasOwnProperty(<span class="string">'name'</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">p1.name = <span class="string">'bzn'</span>;</span><br><span class="line">p1.name; <span class="comment">// bzn; ==&gt; 实例</span></span><br><span class="line"></span><br><span class="line">p1.hasOwnProperty(<span class="string">'name'</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">p2.name; <span class="comment">// baizn ==&gt;  原型</span></span><br><span class="line"></span><br><span class="line">p2.hasOwnProperty(<span class="string">'name'</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><strong>Object.getOwnPropertyDescriptor()方法只能用于实例属性，要获取原型属性的描述符，必须直接在原型对象上调用Object.getOwnPropertyDescriptor()方法。</strong></p>
<p><strong>原型与in操作符</strong></p>
<p>单独使用in操作符时，in操作符会在通过对象能够访问到给定属性时返回true，无论该属性存在与实例中还是原型中。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'name'</span> <span class="keyword">in</span> p1; <span class="regexp">//</span> <span class="keyword">true</span></span><br><span class="line"><span class="string">'name'</span> <span class="keyword">in</span> p2; <span class="regexp">//</span> <span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>使用下面的代码可以确定属性是存在于原型中还是对象中。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span><span class="params">(obj, name)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !obj.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<strong>for-in</strong>循环，返回的是所有能够通过对象访问的，可枚举的属性，包含原型中的属性。</p>
<p><strong>Object.keys()</strong>可以获取对象上所有可枚举的实例属性，接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'bzn'</span>;</span><br><span class="line">Person.prototype.age = <span class="number">10</span>;</span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(Person.prototype); <span class="comment">// name, age, getName</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line">p1.name = <span class="string">'b'</span>;</span><br><span class="line"><span class="built_in">Object</span>.keys(p1); <span class="comment">// name</span></span><br></pre></td></tr></table></figure>
<p><strong>Object.getOwnPropertyNames()</strong>方法会获取到所有实例属性，无论是否可枚举。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype); <span class="comment">// constructor, name, age, getName</span></span><br></pre></td></tr></table></figure>
<p><strong>简单的原型语法</strong></p>
<p>用一个包含所有属性和方法的对象字面量来重写整个原型对象。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">	name: <span class="string">'bzn'</span>,</span><br><span class="line">	age: <span class="number">20</span>,</span><br><span class="line">	getName: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，constructor属性不再指向Person了。constructor属性指向了Object构造函数。</p>
<p>用instanceof操作符测试Object和Person仍返回true，单constructor属性则等于Object而不是Person。</p>
<p>可以通过下面等方式来使constructor重新指向Person。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">	<span class="constructor"><span class="keyword">constructor</span>: Person,</span><br><span class="line">	name: 'bzn',</span><br><span class="line">	age: 20,</span><br><span class="line">	getName: function() </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种重设constructor属性的方式会导致[[Enumerable]]特性被设置为true，默认情况下，constructor属性使不可枚举的。可以通过使用Object.defineProperty()方法重设constructor为不可枚举。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Object</span><span class="class">.defineProperty</span>(Person.prototype, <span class="string">'constructor'</span>, &#123;</span><br><span class="line">	<span class="attribute">enumerable</span>: false,</span><br><span class="line">	<span class="attribute">value</span>: Person</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可以动态为原型添加属性和方法，并且修改能够立即在所有对象的实例中反映出来，但如果是重写整个原型，情况会有所不同。调用构造函数时会为实例添加一个指向最初原型的[[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。<strong>实例中的指针仅指向原型，而不指向构造函数</strong>。</p>
<p><strong>原型对象的问题</strong></p>
<p>原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于基本值的属性也可以，因为通过在实例上添加一个同名属性，就可以隐藏原型中对应属性。但是，对于包含引用类型值的属性来说，就会存在问题，在一个实例上修改，会影响到所有实例。</p>

      
      

      <!-- page.path 表示不含根路径的页面网址。还有数种方式可以匹配页面，在此不赘述。 -->
        
    </div>
    
    <div class="article-info article-info-index">
      
      

      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Object/">Object</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/对象/">对象</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>










  
    <article id="post-React开发躺过的坑" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/18/React开发躺过的坑/" class="article-date">
  	<time datetime="2015-11-18T08:06:39.000Z" itemprop="datePublished">2015-11-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/18/React开发躺过的坑/">React开发躺过的坑</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="React开发过程中躺过的坑">React开发过程中躺过的坑</h2><h3 id="Flux异步请求">Flux异步请求</h3><h4 id="使用官方的Flux架构">使用官方的Flux架构</h4><p>解决方案：监听事件方法添加回调函数，在回调函数中传递异步的结果数据，注册Dispatcher时候，等到异步方法执行完成后再触发事件。</p>
<p>Store中定义的部分关键代码如下：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="type">CHANGE</span> = 'change';</span><br><span class="line"><span class="keyword">let</span> dataObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="type">Store</span> = <span class="type">Object</span>.assign(&#123;&#125;, <span class="type">EventMitter</span>.prototype, &#123;</span><br><span class="line">	emitChange() &#123;</span><br><span class="line">		this.emit(<span class="type">CHANGE</span>);</span><br><span class="line">	&#125;,</span><br><span class="line">	addChangeListener(callback) &#123;</span><br><span class="line">		this.on(<span class="type">CHANGE</span>, () =&gt; &#123;</span><br><span class="line">			callback(dataObj);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getResult = (params) =&gt; &#123;</span><br><span class="line">	$.ajax(&#123;</span><br><span class="line">		url: 'url',</span><br><span class="line">		dataType: 'jsonp'</span><br><span class="line">	&#125;).then(data =&gt; data);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">Dispatcher</span>.register(action =&gt; &#123;</span><br><span class="line">	<span class="keyword">var</span> <span class="literal">result</span> = null;</span><br><span class="line">	switch(action.<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span>: <span class="type">Constant</span>.<span class="type">GET_RESULT</span>:</span><br><span class="line">			<span class="literal">result</span> = getResult(action.params);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		default:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="literal">result</span>.then( () =&gt; &#123;</span><br><span class="line">		<span class="type">Store</span>.emitChange();</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在Component中调用Store的addChangeListener方法时候，在回调中设置state的值。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Store.addChangeListener(<span class="function"><span class="params">(data)</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">this</span>.setState(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过上面的方式可以实现使用官方的Flux时候的异步请求，但这种方式实在太过于麻烦，编写的代码也一定都不直观，可读性较差，为了解决以上问题，我们经过反复的实践及查阅相关资料，最终选用了Flux的另一个实现框架：<strong>alt.js</strong>。</p>
<h4 id="使用alt-js">使用alt.js</h4><p>使用alt实现异步请求逻辑很清晰，代码结构层级及可读性都大大提升。使用alt的一般流程如下：</p>
<blockquote>
<ul>
<li>定义action：action中发送请求，异步请求成功时候也仅仅只需调用action而已</li>
<li>定义store：store中绑定请求成功的action，设置state</li>
<li>Component中使用：通过使用store.listen()和store.unlisten()添加和移除监听事件，其他所有触发事件的事件都只需调用对应的action即可</li>
</ul>
</blockquote>
<p>经过以上三部，已经完美的将alt应用到项目中了。为了方便维护，建议将action中的字符串方法定义为常量。</p>
<p>使用alt的关键代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//action.js</span></span><br><span class="line"><span class="keyword">import</span> alt from <span class="string">'alt'</span>;</span><br><span class="line"><span class="keyword">class</span> Action &#123;</span><br><span class="line">	<span class="constructor"><span class="keyword">constructor</span>() </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.generateActions(Constant.GET_RESULT_SUCCESS);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	getResult() &#123;</span><br><span class="line">		$.ajax(&#123;</span><br><span class="line">			url: <span class="string">'url'</span>,</span><br><span class="line">			dataType: <span class="string">'jsonp'</span></span><br><span class="line">		&#125;).then((data) =&gt; &#123;</span><br><span class="line">			<span class="keyword">this</span>.actions.getResultSuccess(data);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> alt.createActions(Action);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Store.js</span></span><br><span class="line"><span class="keyword">import</span> alt from <span class="string">'alt'</span>;</span><br><span class="line"><span class="keyword">import</span> Action from <span class="string">'../actions/Action'</span>;</span><br><span class="line"><span class="keyword">class</span> Store &#123;</span><br><span class="line">	<span class="constructor"><span class="keyword">constructor</span>() </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.bindActions(Action);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	onGetResultSuccess(data) &#123;</span><br><span class="line">		<span class="built_in">Object</span>.assing(<span class="keyword">this</span>, data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> alt.createStore(Store);</span><br></pre></td></tr></table></figure>
<h4 id="Redux">Redux</h4><p>后续会使用最近火到没朋友的Redux，该部分未完待续。</p>
<h3 id="React-router动态路由">React-router动态路由</h3><p>React 0.13.3和react-router 0.13.3的动态路由解决方案：</p>
<p>使用<a href="https://github.com/luqin/react-router-loader" target="_blank" rel="external">react-router-loader</a>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">Route</span> <span class="attribute">name</span>=<span class="value">'user'</span> <span class="attribute">component</span>=<span class="value">&#123;require('react-router?name=user!.</span>/<span class="attribute">User</span>')&#125;&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">Route</span> <span class="attribute">name</span>=<span class="value">'detail'</span> <span class="attribute">component</span>=<span class="value">&#123;require('react-router?name=user!.</span>/<span class="attribute">Detail</span>')&#125; /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">Route</span> <span class="attribute">name</span>=<span class="value">'setting'</span> <span class="attribute">component</span>=<span class="value">&#123;require('react-router?name=user!.</span>/<span class="attribute">Setting</span>')&#125; /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">Route</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>React 0.14.0以上的版本及react-router 1.0.0@rc以上的版本，将路由和组件放到同一个目录下面，按路由包含关系组织代码结构。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const Routes = &#123;</span><br><span class="line">	<span class="attribute">path</span>: <span class="string">'register'</span>,</span><br><span class="line">	getChildRoutes(location, callback) &#123;</span><br><span class="line">		<span class="built_in">require</span>.ensure([], <span class="function"><span class="params">(<span class="built_in">require</span>)</span> =&gt;</span> &#123;</span><br><span class="line">			callback(<span class="literal">null</span>, [</span><br><span class="line">				<span class="built_in">require</span>(<span class="string">'./routes/Register'</span>),</span><br><span class="line">				<span class="built_in">require</span>(<span class="string">'./routes/Login'</span>)</span><br><span class="line">			])</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;,</span><br><span class="line">	getIndexRoute(location, callback) &#123;</span><br><span class="line">		<span class="built_in">require</span>.ensure([], <span class="function"><span class="params">(<span class="built_in">require</span>)</span> =&gt;</span> &#123;</span><br><span class="line">			callback(<span class="literal">null</span>, &#123;</span><br><span class="line">				<span class="attribute">component</span>: <span class="built_in">require</span>(<span class="string">'./component/Index'</span>)</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;,</span><br><span class="line">	getComponents(location, callback) &#123;</span><br><span class="line">		<span class="built_in">require</span>.ensure([], <span class="function"><span class="params">(<span class="built_in">require</span>)</span> =&gt;</span> &#123;</span><br><span class="line">			callback(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'./components/Main'</span>))</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体示例见<a href="https://github.com/rackt/react-router/tree/master/examples/hug-apps" target="_blank" rel="external">这里</a>。</p>
<h3 id="webpack打包按需加载">webpack打包按需加载</h3><p>React0.13.3版本，按上面动态路由的方式处理后就可以实现按需打包，每次只加载需要的模块。在数据系统这边，我们的UI采用的是Ant-design组件库，由于React和Ant-design两个的体积已经挺大，因此分模块时候不建议分过多的模块，如果分的过多，每次加载的资源反到更多。</p>
<p>另外Webpack也支持多入口及chunk特性，具体可参考以下资料：</p>
<p><a href="https://webpack.github.io/docs" target="_blank" rel="external">Webpack官网</a></p>
<p><a href="baizn.github.io/2015/11/05/Webpack-code-splitting/">Webpack code splitting</a>。</p>
<h3 id="React项目部署">React项目部署</h3><p>项目开发时候可以直接使用webpack提供的webpack-dev-server进行测试，但部署到服务器时候需要自己的WEB服务器，需要将Webpack的服务器集成到已有服务器上面（依赖Node.js环境），来使用webpack提供的模块打包和加载功能。</p>
<p>实现集成只需要将以下代码添加到html中即可。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">'http://127.0.0.1:3000/webpack-dev-server.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了进一步提升性能和安全性，可使用<a href="nginx.org/en/">Nginx</a>进行代理转发。</p>
<h3 id="使用Ant-design过程中遇到的问题">使用Ant-design过程中遇到的问题</h3><h4 id="将Echarts封装成React组件">将Echarts封装成React组件</h4><p>当将Echarts封装成React组件使用时候，只有首次才会调用componentDidMount方法，即没有数据时候渲染一次Echarts图表，当有数据时候只调用render方法，不会在调用componentDidMount方法。如果将渲染图表的renderEcharts方法放到render中，react则会提示不要在render中进行refs操作，因此这种方式不合适。正确的做法是使用componentDidMount和componentDidUpdate，在这两个方法中分别调用renderEcharts方法。</p>
<h4 id="Ant-design_Table_部分渲染不出this-state-xxx_数据">Ant-design Table 部分渲染不出this.state.xxx 数据</h4><p>dataSource={this.state.resultList}，已经正确加载了数据，但页面上没有显示数据，只显示空白row，而将this.state.resultList定义到外面使用就没这个问题。之前的页面直接使用this.state.resultList也没有问题。</p>
<h4 id="Ant-design_Table不支持复杂的表格">Ant-design Table不支持复杂的表格</h4><p>对于一些很复杂的表格（各种colspan和rowspan，并且合并的单元格不规则），Ant-design的Table组件不支持，需要自己重新封装Table组件。</p>
<h3 id="Ant-design_0-9-x_中日期选择年月">Ant-design 0.9.x 中日期选择年月</h3><p>Ant-design 0.9.x的文档中没有说明如何设置只选择年月的部分，通过查看源码，发现只选择年月的是单独的一个组件，需要使用<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;### React&#20013;&#23450;&#20041;&#40664;&#35748;props&#21518;&#21551;&#21160;&#25253;&#35821;&#27861;&#38169;&#35823;&#10;&#23450;&#20041;&#22914;&#19979;&#30340;&#40664;&#35748;props&#23646;&#24615;&#65306;</span><br></pre></td></tr></table></figure></p>
<p>static defaultProps = {<br>    text: ‘baizn’,<br>    compamy: ‘bbc’<br>}<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">启动服务器时候报语法错误。</span><br><span class="line"></span><br><span class="line">问题原因：babel默认将ES6代码编译为ES5代码，而<span class="keyword">static</span>属于ES7中定义的语法，不能识别，因此报语法错误。</span><br><span class="line"></span><br><span class="line">解决方法：webpack配置文件中的babel和babel-loader两个loaders添加stage=<span class="number">0</span>参数，表示将所有属性都编译为ES5代码。</span><br></pre></td></tr></table></figure></p>
<p>loaders: [<br>    {<br>        test: ‘/.jsx?$/‘,<br>        loaders: [‘babel?stage=0’, ‘babel-loader?stage=0’],<br>        exclude: /node_moudles/<br>    }<br>]<br>```</p>
<h4 id="Uncaught_TypeError:__storeStore2-default-getData_is_not_a_function">Uncaught TypeError: _storeStore2.default.getData is not a function</h4><blockquote>
<p>解决方法：检查定义getData方法的文件中是否添加了export default 或 module.exports。</p>
</blockquote>
<h4 id="Module_build_failed:_ReferenceError:_[BABEL]…react-js-Child">Module build failed: ReferenceError: [BABEL]…react.js.Child</h4><blockquote>
<p>npm install –save-dev babel-preset-react babel-preset-es2015</p>
</blockquote>
<h4 id="cannot_resolve_module_‘babel-runtime/core-js/object…’">cannot resolve module ‘babel-runtime/core-js/object…’</h4><blockquote>
<p>npm install babel-polyfill –save</p>
<p>npm install babel-runtime –save</p>
<p>npm install babel-plugin-transform-runtime –save</p>
</blockquote>
<p>详细资料参考<a href="jamesknelson.com/using-es6-in-the-browser-with-babel-6-and-webpack/">这里</a>。</p>
<h4 id="uncexpected_token_illegal_you_may_need_an_appropriate_loader_to_handle_the_files">uncexpected token illegal you may need an appropriate loader to handle the files</h4><p>css中使用了背景图片，并且都配置了css和png的loader。</p>
<blockquote>
<p>将png的loader配置到css前面。</p>
</blockquote>
<h4 id="使用require引入模块时候需要使用module-exports=xx方式导出">使用require引入模块时候需要使用module.exports=xx方式导出</h4><h4 id="Warning:_React-createElement:_type_should_not_be_null,_undefined,_boolean,_or_number-_It_should_be_a_string_(for_DOM_elements)_or_a_ReactClass_(for_composite_components)-_Check_the_render_method_of_Home-">Warning: React.createElement: type should not be null, undefined, boolean, or number. It should be a string (for DOM elements) or a ReactClass (for composite components). Check the render method of <code>Home</code>.</h4><blockquote>
<p>检查import的组件是否export default</p>
</blockquote>
<h4 id="Warning:_Failed_propType:_Invalid_prop_data_of_type_object_supplied_to_Home,_expected_array-_Check_the_render_method_of_Connect(Home)-">Warning: Failed propType: Invalid prop <code>data</code> of type <code>object</code> supplied to <code>Home</code>, expected <code>array</code>. Check the render method of <code>Connect(Home)</code>.</h4><blockquote>
<p>通过this.props传入的值类型和Home.propTypes定义的类型不相同</p>
</blockquote>
<h4 id="Warning:_flattenChildren(…):_Encountered_two_children_with_the_same_key,_-$zx-_Child_keys_must_be_unique;_when_two_children_share_a_key,_only_the_first_child_will_be_used-">Warning: flattenChildren(…): Encountered two children with the same key, <code>.$zx</code>. Child keys must be unique; when two children share a key, only the first child will be used.</h4><p>多个元素有相同的key值。</p>

      
      

      <!-- page.path 表示不含根路径的页面网址。还有数种方式可以匹配页面，在此不赘述。 -->
        
    </div>
    
    <div class="article-info article-info-index">
      
      

      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flux/">Flux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/alt/">alt</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ant-design/">ant-design</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/遇到的问题/">遇到的问题</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>










  
    <article id="post-JavaScript引用类型" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/18/JavaScript引用类型/" class="article-date">
  	<time datetime="2015-11-18T03:12:49.000Z" itemprop="datePublished">2015-11-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/18/JavaScript引用类型/">JavaScript引用类型</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JavaScript引用类型">JavaScript引用类型</h2><h3 id="Array类型">Array类型</h3><p>数组的length属性不是只读的，可以通过设置length属性，从数组的末尾移除数据或向数组中添加新项。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>];</span><br><span class="line">colors.length = <span class="number">1</span>;</span><br><span class="line">colors[<span class="number">1</span>]; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>将其length属性设置为1后会移除最后一个数据，访问colors[1]时候显示undefined。如果将其length设置为大于数组项数的值，则新增的每一项都是undefined。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>];</span><br><span class="line">colors.length = <span class="number">3</span>;</span><br><span class="line">colors[<span class="number">2</span>]; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>利用length属性也可以方便地在数组末尾添加新项。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">var</span> <span class="atom">colors</span> = [<span class="string">'red'</span>, <span class="string">'blue'</span>];</span><br><span class="line"><span class="atom">colors</span>[<span class="atom">colors</span>.<span class="atom">length</span>] = <span class="string">'green'</span>;</span><br><span class="line"><span class="atom">colors</span>[<span class="atom">colors</span>.<span class="atom">length</span>] = <span class="string">'red'</span>;</span><br></pre></td></tr></table></figure>
<p>由于数组最后一项的索引始终是length－1， 因此下一个新项的位置就是length。</p>
<h4 id="检测数组">检测数组</h4><p>对于全局作用域而言，使用instanceof操作符就能确定某个对象是否为数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">	<span class="comment">// is Array</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>instanceof操作符的问题在于它假定只有一个全局执行环境。</strong></p>
<p>ECMAScript5新增了Array.isArray()方法，目的是不管它是在哪个执行环境中创建的都可以确定是不是数组。</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">Array</span>.<span class="built_in">isArray</span>(value)) &#123;</span><br><span class="line">	<span class="comment">//is Array</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="转换方法">转换方法</h4><p>所有对象都具有toLocalString(), toString()和valueOf()方法。调用toString()方法会返回数组中每个值的字符串形式拼接而成的一个以逗号分割的字符串，而调用valueOf方法返回的还是数组。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>];</span><br><span class="line">colors.toString(); <span class="comment">//red, blue</span></span><br><span class="line">colors.valueOf(); <span class="comment">//red, blue</span></span><br></pre></td></tr></table></figure>
<h4 id="栈方法">栈方法</h4><p>栈是一种LIFO（Last In First Out）的数据结构，即最新添加的元素最早被移除。栈中数据的添加和删除都只发生在栈的顶部。</p>
<p>ECMAScript为数字提供了push()和pop()方法，以实现类似栈的行为。</p>
<p>push()方法可以接受任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。</p>
<p>pop()方法则从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。</p>
<h4 id="队列方法">队列方法</h4><p>栈数据结构访问规则是LIFO，而队列数据结构的访问规则是FIFO（First In First Out）。队列在列表的末端添加项，从列表的前端移除项。</p>
<p>shift()方法移除数组的第一个元素并返回该项，同时将数组的长度减1。</p>
<p>ECMAScript还提供了unshift()方法。它能在数组前端添加任意元素并返回新数组的长度。</p>
<h4 id="重排序方法">重排序方法</h4><p>数组中有两个可以直接用来排序的方法：reverse()和sort()。</p>
<p>reverse()方法会反转数组项的顺序。</p>
<p>sort()接收一个比较函数作为参数，比较函数接收两个参数。</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> compareFun(<span class="keyword">value</span><span class="number">1</span>, <span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">value</span><span class="number">1</span> - <span class="keyword">value</span><span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="操作方法">操作方法</h4><blockquote>
<p>concat()方法可以基于当前数组中的所有项创建一个新的数组。</p>
</blockquote>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>];</span><br><span class="line"><span class="keyword">var</span> colors2 = colors.<span class="keyword">concat</span>(<span class="string">'yellow'</span>, [<span class="string">'black'</span>, <span class="string">'brown'</span>]);</span><br><span class="line"></span><br><span class="line">colors; <span class="comment">// red, blue</span></span><br><span class="line">colors2; <span class="comment">// red, blue, yellow, black, brown</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>slice()方法能够基于当前数组中的一个或多个项创建一个新数组</p>
</blockquote>
<p>slice()方法接收一个或两个参数，即要返回项的起始和结束位置。当只有一个参数时，slice()方法返回从该参数开始到当前数组结尾的所有项。</p>
<p><strong>slice()方法不影响原始数组。</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> colors</span> = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>, <span class="string">"yellow"</span>, <span class="string">"purple"</span>];</span><br><span class="line"><span class="variable"><span class="keyword">var</span> colors2</span> = colors.slice(<span class="number">1</span>);</span><br><span class="line"><span class="variable"><span class="keyword">var</span> colors3</span> = colors.slice(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">colors2;   <span class="comment">//green,blue,yellow,purple</span></span><br><span class="line">colors3;   <span class="comment">//green,blue,yellow</span></span><br></pre></td></tr></table></figure>
<p><strong>slice()方法的参数中有负数时候，则用数组长度加上该数来确定相应的位置。</strong></p>
<p>splice()主要用途是向数组的中部插入项。</p>
<p>splice()三大作用：</p>
<blockquote>
<ul>
<li>删除：可以删除任意数量的项，只需指定2个参数（要删除的第一项的位置和要删除的项数）。如splice(0, 2)会删除数组中的前两项</li>
<li>插入：可以向指定位置插入任意数量的项，只需提供3个参数（起始位置，0(要删除的项数)和要插入的项）。如果要插入多个项，可以再传入第四、第五以志任意多项。如splice(2, 0, ‘red’, ‘green’)会从当前数组的位置2开始插入字符串’red’和’green’</li>
<li>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数（起始位置，要删除的项数和要插入的任意数量的项）。插入的项数不必与删除的项数相等。如splice(2, 1, ‘red’, ‘green’)会删除当前数组位置为2的元素，然后再从位置2开始插入字符串’red’和’green’</li>
</ul>
</blockquote>
<p>splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除元素，则返回一个空数组。</p>
<h4 id="位置方法">位置方法</h4><p>ECMAScript为数组实例添加了两个方法：indexOf()和lastIndexOf()。这两个方法都接收两个参数：要查找的项和表示查找起点位置的索引（可选的）。</p>
<p>indexOf()方法从数组的开头（位置0）开始向后查找，lastIndexOf()则从数组的末尾开始向前查找。</p>
<p>这两个方法都返回要查找的项在数组中的位置，没有找到的话返回－1。</p>
<h4 id="迭代方法">迭代方法</h4><p>ECMAScript为数组定义了5个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和运行该函数的作用域对象——影响this的值（可选的）。传入这些方法中的函数会接收三个参数：数组项的值，该项的数组中的位置和数组对象本身。</p>
<blockquote>
<ul>
<li>every()：对数组的每一元素运行给定函数，如果该函数每一项都返回true，则返回true</li>
<li>filter()：对数组中每一元素运行给定函数，返回该函数会返回true的元素组成的数组</li>
<li>forEach()：对数组中每一元素运行给定函数，无返回值</li>
<li>map()：对数组中每一元素运行给定函数，返回每次函数调用的结果组成的数组</li>
<li>some()：对数组中每一元素运行给定函数，如果该函数任一项返回true，则返回true</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">var filterResult = numbers.filter(function(item, index, <span class="built_in">array</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">filterResult; <span class="comment">// 3, 4, 5</span></span><br></pre></td></tr></table></figure>
<p>map()也返回一个数组，而这个数组的每一项都是原始数组中的对应项上运行传入函数的结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">var mapResult = numbers.<span class="built_in">map</span>(function(item, index, <span class="built_in">array</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mapResult; <span class="comment">// [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure>
<h4 id="归并方法">归并方法</h4><p>ECMAScript5新增了两个归并数组的方法：reduce()和reduceRight()。这两个方法都会迭代数组的所有元素，然后构建一个最终返回的值。</p>
<p>reduce()方法从数组的第一个元素开始，逐个遍历到最后，reduceRight()则从数组的最后一项开始，向前遍历到第一个元素。</p>
<p>这两个方法都接收两个参数：一个在每一元素上调用的函数和作为归并基础的初始值（可选的）。传给redux()和reduceRight()的函数接收4个参数：前一个值，当前值，元素的索引和数组对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">var sum = values.reduce(function(prev, cur, index, <span class="built_in">array</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sum; <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>第一次执行回调函数，prev是1， cur是2.第二次prev是3（1+2），cur是3（数组第三项）。这个过程会持续到把数组中的每一项都访问一遍，最后返回结果。</p>
<p>reduceRight()的作用类似，只不过方向相反而已。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">var sum = values.reduceRight(function(prev, cur, index, <span class="built_in">array</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sum; <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>第一次执行回调函数，prev是5，cur是4。</p>
<h3 id="Date类型">Date类型</h3><p>Date.parse()方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。</p>
<p>Date.parse()参数的可选格式：</p>
<blockquote>
<ul>
<li>“月／日／年”：如6/12/2015</li>
<li>“英文月 日, 年”：如January 12， 2015</li>
<li>“英文星期几 英文月 日 年 时: 分: 秒: 时区”：如Tue May 25 2015 00:00:00 GMT-0700</li>
<li>ISO 8601扩展格式YYYY-MM-DDTHH:mm:ss:sssZ，如2015-05-25T00:00:00</li>
</ul>
</blockquote>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">date</span> = <span class="literal">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span><span class="built_in">.</span>parse(<span class="string">'May 25, 2015'</span>));</span><br></pre></td></tr></table></figure>
<p>Date.UTC()方法也返回表示日期的毫秒数，参数分别是年份，月份（从0开始），日（1－31），小时数（0-23），分钟，秒以及毫秒。只有年月参数是必须按的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var date = <span class="keyword">new</span> Date(Date.UTC(<span class="number">2000</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">var date1 = <span class="keyword">new</span> Date(Date.UTC(<span class="number">2015</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">55</span>, <span class="number">55</span>));</span><br></pre></td></tr></table></figure>
<p><strong>创建Date对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var date = <span class="keyword">new</span> Date(<span class="number">2015</span>, <span class="number">0</span>);</span><br><span class="line">var date1 = <span class="keyword">new</span> Date(<span class="number">2015</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">45</span>, <span class="number">25</span>);</span><br></pre></td></tr></table></figure>
<p>ECMAScript添加了Date.now()方法，返回表示调用这个方法的日期和时间的毫秒数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var <span class="operator"><span class="keyword">start</span> = <span class="built_in">Date</span>.<span class="keyword">now</span>();</span></span><br><span class="line"></span><br><span class="line">var <span class="operator"><span class="keyword">stop</span> = <span class="built_in">Date</span>.<span class="keyword">now</span>();</span></span><br><span class="line"></span><br><span class="line">var result = <span class="operator"><span class="keyword">stop</span> - <span class="keyword">start</span>;</span></span><br></pre></td></tr></table></figure>
<p>在不支持Date.now()的浏览器中，使用＋操作符把Date对象转成字符串。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var <span class="operator"><span class="keyword">start</span> = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"></span><br><span class="line">var <span class="operator"><span class="keyword">stop</span> = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"></span><br><span class="line">var result = <span class="operator"><span class="keyword">stop</span> - <span class="keyword">start</span>;</span></span><br></pre></td></tr></table></figure>
<h3 id="RegExp类型">RegExp类型</h3><p>ECMAScript通过RegExp类型来支持正则表达式。</p>
<p>正则表达式的匹配模式支持下面3个标志：</p>
<blockquote>
<ul>
<li>g：全局模式，即模式将应用于所有字符串，而非在发现第一个匹配项时立即停止</li>
<li>i：不区分大小写模式</li>
<li>m：多行模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项</li>
</ul>
</blockquote>
<p>模式中的所有<strong>元字符</strong>都必须转义。正则表达式中的元字符包括：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">( <span class="collection">[ <span class="collection">&#123; \ ^ $ | ) ? * + . ]</span> &#125;</span></span></span><br></pre></td></tr></table></figure>
<p>定义正则表达式可以采用字面量的形式，也可以采用RegExp构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是标志字符串（可选的）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'[bc]at'</span>, <span class="string">'i'</span>);</span><br></pre></td></tr></table></figure>
<p><strong>传递给RegExp构造函数的两个参数都是字符串，所有元字符都必须双重转义。</strong></p>
<h4 id="RegExp实例属性">RegExp实例属性</h4><p>RegExp的每个实例都具有下列属性：</p>
<blockquote>
<ul>
<li>global：布尔值，表示是否设置了g标志</li>
<li>ignoreCase：布尔值，表示是否设置了i标志</li>
<li>lastIndex：整数，表示是否设置了下一个匹配项的字符位置，从0算起</li>
<li>multiline：布尔值，表示是否设置了m标志</li>
<li>source：正则表达式的字符串形式</li>
</ul>
</blockquote>
<h4 id="RegExp实例方法">RegExp实例方法</h4><p>RegExp对象的主要方法是<strong>exec()</strong>，该方法是专门为捕获组而设计的。exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null。返回的数组虽然是Array的实例，但包含两个额外的属性：index和input。index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var text = 'mom <span class="keyword">and</span> dad <span class="keyword">and</span> baby';</span><br><span class="line">var pattern = /mom( <span class="keyword">and</span> dad( <span class="keyword">and</span> baby)?)?/gi;</span><br><span class="line"></span><br><span class="line">var <span class="operator">matches</span> = pattern.exec(text);</span><br><span class="line"><span class="operator">matches</span>.index; // <span class="number">0</span></span><br><span class="line"><span class="operator">matches</span>.input; // mom <span class="keyword">and</span> dad <span class="keyword">and</span> baby</span><br><span class="line"><span class="operator">matches</span>[<span class="number">0</span>]; // mom <span class="keyword">and</span> dad <span class="keyword">and</span> baby</span><br><span class="line"><span class="operator">matches</span>[<span class="number">1</span>]; // <span class="keyword">and</span> dad <span class="keyword">and</span> baby</span><br><span class="line"><span class="operator">matches</span>[<span class="number">2</span>]; // <span class="keyword">and</span> baby</span><br></pre></td></tr></table></figure>
<p>exec()方法，即使在模式字符串中设置了全局标志(g)，它每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一匹配项的信息，而在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项。</p>
<p><strong>test()</strong>方法，接受一个字符串参数。在模式与该参数匹配的情况下返回true，否则返回false。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">'00-000'</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/\d&#123;2&#125;-\d&#123;3&#125;/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pattern.test(text)) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'matched'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正则表达式的valueOf()方法返回正则表达式本身。</strong></p>
<h4 id="RegExp的属性">RegExp的属性</h4><blockquote>
<ul>
<li>input($_)：最近一次要匹配的字符串</li>
<li>lastMatch($&amp;)：最近一次的匹配项</li>
<li>lastParen($+)：最近一次匹配的捕获组</li>
<li>leftContext($`)：input字符串中lastMatch之前的文本</li>
<li>multiline($*)：布尔值，表示是否所有表达式都使用多行模式</li>
<li>rightContext($’)：input字符串中lastMatch之后的文本</li>
</ul>
</blockquote>
<p>另外还有9个用于存储捕获组的构造函数属性。访问这些属性的语法是RegExp.$1，RegExp.$2……RegExp.$9，分别用于存储第一，第二到第九个匹配的捕获组。在调用exec()或test()方法时，这些属性会自动被填充。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var text = <span class="string">'this has been a short summer'</span>;</span><br><span class="line">var pattern = /(..)or(.)/g;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pattern.test(text)) &#123;</span><br><span class="line">	RegExp.<span class="variable">$1</span>; // sh</span><br><span class="line">	RegExp.<span class="variable">$2</span>; // t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Function类型">Function类型</h3><p>函数实际上是对象。每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际也是一个指向函数对象的指针，不会与某个函数绑定。</p>
<p><strong>函数是对象，函数名是指针。</strong></p>
<p>由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同，即一个函数可能会有多个名子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">sum</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">var anotherSum = sum;</span><br><span class="line">anotherSum(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">sum = null;</span><br><span class="line">anotherSum(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<h4 id="函数声明与函数表达式">函数声明与函数表达式</h4><p>解析器率先读取函数声明，并使其在执行任何代码之前可用；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。</p>
<h4 id="作为值的函数">作为值的函数</h4><p>因为ECMAScript中的函数名本身就是变量，所以函数也可以作为值来使用。即不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeFunction</span><span class="params">(someFunction, someArgument)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> someFunction(someArgument);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，也可以从一个函数中返回另一个函数。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span><span class="params">(pname)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(o1, o2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> value1 = o1[pname];</span><br><span class="line">		<span class="keyword">var</span> value2 = o2[pname];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> value1 - value2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数内部属性">函数内部属性</h4><p>函数内部，有两个特色的对象：arguments和this。arguments是一个类数组对象，包含着传入函数中的所有参数。arguments有一个名为callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">fatorial</span><span class="params">(num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(num &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="function">num * <span class="title">facorial</span><span class="params">(num - <span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用arguments.callee实现上面的代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">fatorial</span><span class="params">(num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(num &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> num * arguments.callee(num - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>this对象</strong>引用的是函数赖以执行的环境对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">'red'</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">	color: <span class="string">'blue'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getColor(); <span class="comment">// red</span></span><br><span class="line"></span><br><span class="line">o.getColor = getColor;</span><br><span class="line">o.getColor(); <span class="comment">// blue</span></span><br></pre></td></tr></table></figure>
<p>在调用函数之前，this的值并不确定，因此this可能会在代码执行过程中引用不同的对象。当在全局调用时，this引用的是全局对象window；当把函数赋值给对象后，this就指向该对象。</p>
<p>ECMAScript5也规范了另外一个函数对象的属性：caller。该属性中保存着调用当前函数的引用，如果在全局作用域中调用当前函数，caller的值为null。</p>
<p><strong>callee和caller都不能使用在严格模式下。</strong></p>
<h4 id="函数属性和方法">函数属性和方法</h4><p>ECMAScript中的函数是对象，因此函数也有属性和方法。每个函数都包含两个属性：length和prototype。length属性表示函数希望接收的命名参数个数。prototype属性保存函数所有的实例方法。prototype属性是无法枚举的。</p>
<p>每个函数都包含两个非继承的方法：<strong>apply()和call()</strong>。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。</p>
<p>apply()方法接收两个参数：一个是在其中运行函数的作用域，另外一个是参数数组（可以是数组Array的实例，也可以是arguments对象）。</p>
<p>call()方法第一个参数是其中运行函数的作用域，其他参数是单个的参数列表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">sum</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum.call(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line">sum.apply(<span class="keyword">this</span>, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p><strong>apply()和call()真正强大的地方是能够扩充函数赖以运行的作用域。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">'red'</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">	color: <span class="string">'blue'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getColor(); <span class="comment">// red</span></span><br><span class="line"></span><br><span class="line">getColor.call(<span class="keyword">this</span>); <span class="comment">// red</span></span><br><span class="line">getColor.call(<span class="built_in">window</span>); <span class="comment">// red</span></span><br><span class="line">getColor.call(o); <span class="comment">// blue</span></span><br></pre></td></tr></table></figure>
<p>使用call()或apply()方法来扩充作用域的最大好处是对象不需要与方法有任何耦合关系。</p>
<p><strong>bind()</strong>方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">'red'</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">	color: <span class="string">'blue'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> objectColor = getColor.bind(o);</span><br><span class="line">objectColor(); <span class="comment">// blue</span></span><br></pre></td></tr></table></figure>
<h3 id="基本包装类型">基本包装类型</h3><p>ECMAScript提供了3个特殊的引用类型：Boolean、Number和String。</p>
<p>引用类型和基本包装类型的主要区别就是<strong>对象的生存期</strong>。使用new操作符创建的引用类型的实例如，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。即不能在运行时为基本类型值添加属性和方法。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">str</span> = <span class="string">'bzn come from xxx'</span>;</span><br><span class="line"><span class="keyword">str</span>.name = <span class="string">'ok'</span>;</span><br><span class="line"><span class="keyword">str</span>.name; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p><strong>对基本包装类型的实例调用typeof会返回“object”。</strong></p>
<h4 id="Boolean类型">Boolean类型</h4><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> falseObj = new <span class="type">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="literal">result</span> falseObj &amp;&amp; <span class="literal">true</span>;</span><br><span class="line"><span class="literal">result</span>; // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> falseObj = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="literal">result</span> falseObj &amp;&amp; <span class="literal">true</span>;</span><br><span class="line"><span class="literal">result</span>; // <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>由于布尔表达式中的所有对象都会被转换为true，因此falseObj对象在布尔表达式中代表的是true。</p>
<p>基本类型与引用类型的布尔值还有两个区别：</p>
<blockquote>
<ul>
<li>typeof操作符对基本类型返回“boolean”，而对引用类型返回“object”</li>
<li>由于Boolean对象是Boolean类型的实例，所以使用instanceof操作符测试Boolean对象都会返回true，而测试基本类型的布尔值返回false</li>
</ul>
</blockquote>
<h4 id="Number类型">Number类型</h4><p><strong>toFixed()</strong> 方法会按照指定的小数位返回数值的字符串表示。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">num</span>.toFixed(<span class="number">2</span>); <span class="comment">// 10.00</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">10.0005</span>;</span><br><span class="line"><span class="built_in">num</span>.toFixed(<span class="number">3</span>); <span class="comment">// 10.006</span></span><br></pre></td></tr></table></figure>
<p><strong>toExponential()</strong>方法返回以指数表示法(e表示法)表示的数值的字符串形式，接收一个参数，指定输出结果中的小数位数。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">num</span>.toExponential(<span class="number">1</span>); <span class="comment">// 1.0e+1</span></span><br></pre></td></tr></table></figure>
<p><strong>toPrecision()</strong>方法会返回固定大小格式，也可能返回指数格式，接收一个参数，表示数值的所有数字的位数，不包含指数部分。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">99</span>;</span><br><span class="line"><span class="built_in">num</span>.toPrecision(<span class="number">1</span>); <span class="comment">// 1e+2</span></span><br><span class="line"><span class="built_in">num</span>.toPrecision(<span class="number">2</span>); <span class="comment">// 99</span></span><br><span class="line"><span class="built_in">num</span>.toPrecision(<span class="number">3</span>); <span class="comment">// 99.0</span></span><br></pre></td></tr></table></figure>
<p>使用typeof操作符测试基本类型数值时，始终返回“number”，而在测试Number对象时，则会返回“object”。Number对象是Number类型的实例，而基本类型的数值则不是。</p>
<h4 id="String_类型">String 类型</h4><p><strong>字符方法</strong></p>
<blockquote>
<p>charAt()和charCodeAt()</p>
</blockquote>
<p>以上两个方法用于访问字符串中特定字符，都接收一个参数，即基于0的字符位置。</p>
<p>charAt()方法以单字符字符串的形式返回给定位置的那个字符。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">str</span> = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">str</span>.charAt(<span class="number">1</span>); <span class="comment">// e</span></span><br></pre></td></tr></table></figure>
<p>如果不需要字符，而需要字符编码，则使用charCodeAt()方法。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">str</span> = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">str</span>.charCodeAt(<span class="number">1</span>); <span class="comment">//101</span></span><br></pre></td></tr></table></figure>
<p>访问字符串中特定位置的字符，还可以使用方括号加数字索引。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">str</span> = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">str</span>[<span class="number">2</span>]; <span class="comment">// l</span></span><br></pre></td></tr></table></figure>
<p><strong>字符串操作方法</strong></p>
<blockquote>
<p>concat()：将一个或多个字符串拼接起来，返回拼接得到的新字符串</p>
</blockquote>
<p>concat()方法可以接收任意多个参数。</p>
<blockquote>
<p>slice(), substr()和substring()</p>
</blockquote>
<p>上面三个方法都会返回被操作字符串的一个子字符串，都接收一个或两个参数。第一个参数指定字符串的开始位置，第二个参数表示子字符串结束位置。 slice()和substring()的第二个参数指定的是子字符串最后一个字符后面的位置；substr()的第二个参数指定的则是返回的字符个数。如果不传递第二个参数，则将字符串的长度作为结束位置。</p>
<p>当传入的参数位负数时候：</p>
<blockquote>
<ul>
<li>slice()方法会将传入的负值与字符串长度相加</li>
<li>substr()方法将第一个参数加上字符串长度，第二个参数转换为0</li>
<li>substring()方法会把所有负值都转换为0</li>
</ul>
</blockquote>
<p><strong>字符串位置方法</strong></p>
<blockquote>
<p>indexOf()和lastIndexOf()</p>
</blockquote>
<p>这两个方法用于从字符串中查找子字符串，然后返回子字符串的位置，如果没有找到则返回－1。区别在于：<strong>indexOf()方法从字符串的开头向后搜索，而lastIndexOf()方法是从字符串的末尾向前搜索子字符串。</strong></p>
<p>这两个方法都可以接收可选的第二个参数，表示从字符串中的哪个位置开始搜索。</p>
<p><strong>trim()方法</strong></p>
<p>trim()方法会创建一个字符串的副本，删除前后的所有空格，然后返回结果。</p>
<p>trimLeft()和trimRight()分别会删除字符串开头和结尾的空格。</p>
<p><strong>字符串大小写转换方法</strong></p>
<blockquote>
<p>toLowerCase() / toUpperCase()<br>toLocalLowerCase() / toLocalUpperCase()</p>
</blockquote>
<p><strong>字符串模式匹配方法</strong></p>
<blockquote>
<p>match()</p>
</blockquote>
<p>match()方法只接收一个参数，正则表达式或RegExp对象。在字符串上调用match方法，本质上和调用RegExp的exec()方法相同。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> text</span> = 'cat, bat, sat';</span><br><span class="line"><span class="variable"><span class="keyword">var</span> pattern</span> = /.at/;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与pattern.exec(text)相同</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> matches</span> = text.match(pattern);</span><br><span class="line">matches.index; <span class="comment">// 0</span></span><br><span class="line">matches[<span class="number">0</span>]; <span class="comment">// cat</span></span><br><span class="line">pattern.lastIndex; <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>search()</p>
</blockquote>
<p>search()方法接收一个参数，由字符串或RegExp对象指定的正则表达式，返回字符串中第一个匹配项的索引，如果没有匹配项，则返回－1。search()方法从字符串开头向后查找。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">'cat, bat'</span>;</span><br><span class="line"><span class="keyword">var</span> pos = text.search(<span class="regexp">/at/</span>);</span><br><span class="line">pos; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>replace()</p>
</blockquote>
<p>replace()方法接收两个参数：第一个参数是字符串或RegExp对象，第二个参数是字符串或函数。如果第一个参数是字符串，那么只会替换第一个字符串，如果要替换所有的子字符串，则只能提供一个正则表达式，且指定全局标志。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = 'bat, cat, fat';</span><br><span class="line"><span class="keyword">var</span> <span class="literal">result</span> = text.replace('at', 'ond');</span><br><span class="line"><span class="literal">result</span>; //bond, cat, fat</span><br><span class="line"></span><br><span class="line"><span class="literal">result</span> = text.replace(/at/g, 'ond');</span><br><span class="line"><span class="literal">result</span>; // bond, cond, fond</span><br></pre></td></tr></table></figure>
<p>如果第二个参数是字符串，则可以使用一些特殊的字符序列，将正则表达式操作得到的值插入到结果字符串中。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = 'cat, bat, fat';</span><br><span class="line"><span class="literal">result</span> = text.replace(/(.at)/g, 'h($<span class="number">1</span>)');</span><br><span class="line"><span class="literal">result</span>; //h(cat), h(bat), h(fat)</span><br></pre></td></tr></table></figure>
<p>replace()方法的第二个参数也可以是一个函数。在只有一个匹配项的情况下，会向这个函数传递3个参数：模式的匹配项，模式匹配项在字符串中的位置和原始字符串。当正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项，第一个捕获组，第二个捕获组……，最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEscape</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> text.replace(<span class="regexp">/[&lt;&gt;"&amp;]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, pos, originalText</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">switch</span>(match) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'&lt;'</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">'&amp;lt;'</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'&gt;'</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">'&amp;gt'</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'&amp;'</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">'&amp;amp;'</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'\"'</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">'&amp;quot;'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">htmlEscape(<span class="string">"&lt;p class=\"greeting\"&gt;Hello world!&lt;/p&gt;"</span>); <span class="comment">//&amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&amp;lt;/p&amp;gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>split()</p>
</blockquote>
<p>split()方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象。split()可以接收第二个参数，用于指定数组的大小。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var text = <span class="string">'bat, cat, fat'</span>;</span><br><span class="line">text.split(<span class="string">','</span>); <span class="regexp">//</span>[<span class="string">'bat'</span>, <span class="string">'cat'</span>, <span class="string">'fat'</span>]</span><br><span class="line">text.split(<span class="string">','</span>, <span class="number">2</span>); <span class="regexp">//</span> [<span class="string">'bat'</span>, <span class="string">'cat'</span>]</span><br><span class="line">text.split(<span class="regexp">/[^\,]+/</span>); <span class="regexp">//</span> [<span class="string">''</span>, <span class="string">','</span>, <span class="string">''</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>localCompare()方法</p>
</blockquote>
<p>localCompare()方法比较两个字符串，并返回下列值中的一个：</p>
<blockquote>
<ul>
<li>如果字符串在字母表中应该排在字符串参数之前，则返回一个负数</li>
<li>如果字符串等于字符串参数，则返回0</li>
<li>如果字符串在字母表中应该排在字符串参数之后，则返回一个正数</li>
</ul>
<p>fromCharCode()</p>
</blockquote>
<p>fromCharCode()是一个静态方法，接收一个或多个字符编码，然后将它们转换成一个字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String.fromCharCode(<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>);  <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
<h3 id="单体内置对象">单体内置对象</h3><p>ECMAScript对内置对象的定义是：由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。</p>
<h4 id="Global对象">Global对象</h4><p>isNaN(), isFinite(), parseInt()及parseFloat()等都是Global对象的方法。</p>
<p><strong>URL编码方法</strong></p>
<p>Global对象的encodeURI()和encodeURIComponent()方法可以对URI进行编码。</p>
<p>encodeURI()主要用于整个URI，而encodeURIComponent()主要用于对URI中的某一段进行编码。</p>
<p>encodeURI()不会对本身属于URI的特殊字符进行编码，如冒号，正斜杠，？＃等；而encodeURIComponent()则会对它发现的任何非法标准字符进行编码。</p>
<p>与encodeURI()和encodeURIComponent()对应的两个方法分别是decodeURI()和decodeURIComponent()。</p>
<p><strong>eval()方法</strong></p>
<p>eval()方法类似一个完整的ECMAScript解析器，它只接收一个参数，即要执行的ECMAScript字符串。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval<span class="list">(<span class="quoted">'console</span>.log<span class="list">(<span class="string">"hi"</span>)</span>')</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>当解析器发现代码中调用eval()方法时，它会将传入的参数当作实际的ECMAScript语句来解析。</p>
<p>在eval()中创建的任何变量和函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中，它们只在eval()执行的时候创建。</p>
<p>严格模式下，在外部访问不到eval()中创建的任何变量或函数，为eval赋值也会导致错误。</p>
<h4 id="Math对象">Math对象</h4><p><strong>min()和max()方法</strong></p>
<p>min()和max()方法用于确定一组数值中的最小值和最大值。这两个方法都可以接收任意多个数值参数。</p>
<p>要找出数组中的最大值或最小值，可以使用apply()方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, values);</span><br></pre></td></tr></table></figure>
<p><strong>舍入方法</strong></p>
<blockquote>
<ul>
<li>Math.ceil()执行向上舍入</li>
<li>Math.floor()执行向下舍入</li>
<li>Math.round()执行标准舍入</li>
</ul>
</blockquote>
<p><strong>random()方法</strong></p>
<p>Math.random()方法返回大于0小于1的一个随机数。套用下面的公司，可以利用Math.random()从某个整数范围内随机选择一个值。</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = Math.<span class="built_in">floor</span>(Math.<span class="built_in">random</span>() * 可能值的总数 + 第一个可能的值)</span><br></pre></td></tr></table></figure>
<p>上面的代码可以使用如下方法替代：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectRandom</span>(<span class="params">lower, upper</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> choices = upper - lower + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * choices + lower);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">selectRandom(<span class="number">2</span>, <span class="number">15</span>); <span class="comment">// 介于2到15之前的随机数</span></span><br></pre></td></tr></table></figure>

      
      

      <!-- page.path 表示不含根路径的页面网址。还有数种方式可以匹配页面，在此不赘述。 -->
        
    </div>
    
    <div class="article-info article-info-index">
      
      

      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/引用类型/">引用类型</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>










  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2016 baizn
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的静态博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减双栏 Hexo 博客主题">Yelee</a> by MOxFIVE
        </div>
    </div>
    <div class="visit">
      <span id="busuanzi_container_site_pv" style='display:none'>
        <span id="site-visit" >本站到访数: 
        <span id="busuanzi_value_site_uv"></span>
        </span>
      </span>
      <span id="busuanzi_container_page_pv" style='display:none'>
        <span id="page-visit">, 本页阅读量: 
        <span id="busuanzi_value_page_pv"></span>
        </span>
      </span>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>

  <style type="text/css">
    body {
      background: lightgray;
    }
    #container .left-col {
      background: white;
    }
    .article-inner {
      background: white;
    }
    .post-nav-button {
      background: #ececec;
    }
    #header .header-nav .social #GitHub {
      background-color: #bfd3ec;
    }
  </style>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
<a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
<a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>