<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JavaScript引用类型 | baizn的github博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="JavaScript引用类型Array类型数组的length属性不是只读的，可以通过设置length属性，从数组的末尾移除数据或向数组中添加新项。
123var colors = [&apos;red&apos;, &apos;blue&apos;];colors.length = 1;colors[1]; // undefined
将其length属性设置为1后会移除最后一个数据，访问colors[1]时候显示undefined。如果">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript引用类型">
<meta property="og:url" content="http://baizn.github.io/2015/11/18/JavaScript引用类型/index.html">
<meta property="og:site_name" content="baizn的github博客">
<meta property="og:description" content="JavaScript引用类型Array类型数组的length属性不是只读的，可以通过设置length属性，从数组的末尾移除数据或向数组中添加新项。
123var colors = [&apos;red&apos;, &apos;blue&apos;];colors.length = 1;colors[1]; // undefined
将其length属性设置为1后会移除最后一个数据，访问colors[1]时候显示undefined。如果">
<meta property="og:updated_time" content="2015-11-18T03:13:17.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript引用类型">
<meta name="twitter:description" content="JavaScript引用类型Array类型数组的length属性不是只读的，可以通过设置length属性，从数组的末尾移除数据或向数组中添加新项。
123var colors = [&apos;red&apos;, &apos;blue&apos;];colors.length = 1;colors[1]; // undefined
将其length属性设置为1后会移除最后一个数据，访问colors[1]时候显示undefined。如果">
  
    <link rel="alternative" href="/atom.xml" title="baizn的github博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/avatar.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">baizn</a></h1>
		</hgroup>

		
				


		
			<div id="switch-btn" class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div id="switch-area" class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives/">所有文章</a></li>
				        
							<li><a href="/tags/">标签云</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<ul class="social">
							
								<li id="Email"><a class="Email" target="_blank" href="/baizhanning@zhubajie.com" title="Email"></a></li>
					        
								<li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/baizn/baizn.github.io" title="GitHub"></a></li>
					        
								<li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
					        
						</ul>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/API/" style="font-size: 12px;">API</a> <a href="/tags/Ajax/" style="font-size: 10px;">Ajax</a> <a href="/tags/BFC/" style="font-size: 10px;">BFC</a> <a href="/tags/CORS/" style="font-size: 10px;">CORS</a> <a href="/tags/CSS/" style="font-size: 14px;">CSS</a> <a href="/tags/Cache/" style="font-size: 10px;">Cache</a> <a href="/tags/Component/" style="font-size: 12px;">Component</a> <a href="/tags/Cookie/" style="font-size: 10px;">Cookie</a> <a href="/tags/Document/" style="font-size: 10px;">Document</a> <a href="/tags/Drag/" style="font-size: 10px;">Drag</a> <a href="/tags/ECMAScript/" style="font-size: 14px;">ECMAScript</a> <a href="/tags/ES6/" style="font-size: 12px;">ES6</a> <a href="/tags/ES6/" style="font-size: 10px;">ES6+</a> <a href="/tags/Element/" style="font-size: 10px;">Element</a> <a href="/tags/Float/" style="font-size: 10px;">Float</a> <a href="/tags/Flux/" style="font-size: 10px;">Flux</a> <a href="/tags/Function/" style="font-size: 10px;">Function</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/MEAT/" style="font-size: 10px;">MEAT</a> <a href="/tags/Middleware/" style="font-size: 10px;">Middleware</a> <a href="/tags/Object/" style="font-size: 10px;">Object</a> <a href="/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/tags/Props/" style="font-size: 12px;">Props</a> <a href="/tags/React/" style="font-size: 18px;">React</a> <a href="/tags/React-router/" style="font-size: 10px;">React-router</a> <a href="/tags/React组件/" style="font-size: 10px;">React组件</a> <a href="/tags/React顶层API/" style="font-size: 10px;">React顶层API</a> <a href="/tags/Redux/" style="font-size: 16px;">Redux</a> <a href="/tags/SPA/" style="font-size: 10px;">SPA</a> <a href="/tags/Thunk/" style="font-size: 10px;">Thunk</a> <a href="/tags/action/" style="font-size: 10px;">action</a> <a href="/tags/after伪元素/" style="font-size: 10px;">after伪元素</a> <a href="/tags/alt/" style="font-size: 10px;">alt</a> <a href="/tags/ant-design/" style="font-size: 10px;">ant-design</a> <a href="/tags/apply/" style="font-size: 10px;">apply</a> <a href="/tags/async/" style="font-size: 10px;">async</a> <a href="/tags/bind/" style="font-size: 10px;">bind</a> <a href="/tags/call/" style="font-size: 10px;">call</a> <a href="/tags/clearfix/" style="font-size: 10px;">clearfix</a> <a href="/tags/codeSplitting/" style="font-size: 10px;">codeSplitting</a> <a href="/tags/componentWillReceiveProps/" style="font-size: 10px;">componentWillReceiveProps</a> <a href="/tags/div/" style="font-size: 10px;">div</a> <a href="/tags/div拖拽/" style="font-size: 10px;">div拖拽</a> <a href="/tags/instanceof/" style="font-size: 10px;">instanceof</a> <a href="/tags/jQuery/" style="font-size: 10px;">jQuery</a> <a href="/tags/meat/" style="font-size: 10px;">meat</a> <a href="/tags/prototype/" style="font-size: 10px;">prototype</a> <a href="/tags/reducer/" style="font-size: 10px;">reducer</a> <a href="/tags/referrer/" style="font-size: 10px;">referrer</a> <a href="/tags/server-render/" style="font-size: 10px;">server render</a> <a href="/tags/state/" style="font-size: 12px;">state</a> <a href="/tags/store/" style="font-size: 10px;">store</a> <a href="/tags/type-file/" style="font-size: 10px;">type=file</a> <a href="/tags/typeof/" style="font-size: 10px;">typeof</a> <a href="/tags/webpack/" style="font-size: 12px;">webpack</a> <a href="/tags/事件处理/" style="font-size: 10px;">事件处理</a> <a href="/tags/优化/" style="font-size: 10px;">优化</a> <a href="/tags/优缺点/" style="font-size: 10px;">优缺点</a> <a href="/tags/作用域/" style="font-size: 10px;">作用域</a> <a href="/tags/全屏自适应/" style="font-size: 10px;">全屏自适应</a> <a href="/tags/单页面Web应用/" style="font-size: 10px;">单页面Web应用</a> <a href="/tags/原型链/" style="font-size: 10px;">原型链</a> <a href="/tags/可复用组件/" style="font-size: 10px;">可复用组件</a> <a href="/tags/坐标/" style="font-size: 10px;">坐标</a> <a href="/tags/垃圾回收/" style="font-size: 10px;">垃圾回收</a> <a href="/tags/实例/" style="font-size: 10px;">实例</a> <a href="/tags/客户端/" style="font-size: 10px;">客户端</a> <a href="/tags/对象/" style="font-size: 10px;">对象</a> <a href="/tags/异步/" style="font-size: 10px;">异步</a> <a href="/tags/引用类型/" style="font-size: 10px;">引用类型</a> <a href="/tags/执行环境/" style="font-size: 10px;">执行环境</a> <a href="/tags/插件开发/" style="font-size: 10px;">插件开发</a> <a href="/tags/改进/" style="font-size: 10px;">改进</a> <a href="/tags/数据流/" style="font-size: 10px;">数据流</a> <a href="/tags/文本框样式/" style="font-size: 10px;">文本框样式</a> <a href="/tags/服务端渲染/" style="font-size: 10px;">服务端渲染</a> <a href="/tags/术语/" style="font-size: 10px;">术语</a> <a href="/tags/样式修改/" style="font-size: 10px;">样式修改</a> <a href="/tags/检测/" style="font-size: 10px;">检测</a> <a href="/tags/清除浮动/" style="font-size: 10px;">清除浮动</a> <a href="/tags/状态/" style="font-size: 10px;">状态</a> <a href="/tags/生命周期/" style="font-size: 12px;">生命周期</a> <a href="/tags/类型检测/" style="font-size: 10px;">类型检测</a> <a href="/tags/纯函数/" style="font-size: 10px;">纯函数</a> <a href="/tags/组件/" style="font-size: 10px;">组件</a> <a href="/tags/继承/" style="font-size: 10px;">继承</a> <a href="/tags/翻译/" style="font-size: 14px;">翻译</a> <a href="/tags/自动分号插入/" style="font-size: 10px;">自动分号插入</a> <a href="/tags/跨域/" style="font-size: 10px;">跨域</a> <a href="/tags/跨浏览器/" style="font-size: 10px;">跨浏览器</a> <a href="/tags/连续赋值/" style="font-size: 10px;">连续赋值</a> <a href="/tags/遇到的问题/" style="font-size: 10px;">遇到的问题</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">人活着如果没有梦想，那和咸鱼还有什么区别－－－专注于前端, 专注于JavaScript</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">baizn</a></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<a href="/" class="profilepic">
				<img lazy-src="/img/avatar.png" class="js-avatar">
			</a>
			<hgroup>
			  <h1 class="header-author"><a href="/" title="回到主页">baizn</a></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives/">所有文章</a></li>
		        
					<li><a href="/tags/">标签云</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
						<ul class="social">
							
								<li id="Email"><a class="Email" target="_blank" href="/baizhanning@zhubajie.com" title="Email"></a></li>
					        
								<li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/baizn/baizn.github.io" title="GitHub"></a></li>
					        
								<li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
					        
						</ul>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-JavaScript引用类型" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/18/JavaScript引用类型/" class="article-date">
  	<time datetime="2015-11-18T03:12:49.000Z" itemprop="datePublished">2015-11-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JavaScript引用类型
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/引用类型/">引用类型</a></li></ul>
	</div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JavaScript引用类型">JavaScript引用类型</h2><h3 id="Array类型">Array类型</h3><p>数组的length属性不是只读的，可以通过设置length属性，从数组的末尾移除数据或向数组中添加新项。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>];</span><br><span class="line">colors.length = <span class="number">1</span>;</span><br><span class="line">colors[<span class="number">1</span>]; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>将其length属性设置为1后会移除最后一个数据，访问colors[1]时候显示undefined。如果将其length设置为大于数组项数的值，则新增的每一项都是undefined。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>];</span><br><span class="line">colors.length = <span class="number">3</span>;</span><br><span class="line">colors[<span class="number">2</span>]; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>利用length属性也可以方便地在数组末尾添加新项。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">var</span> <span class="atom">colors</span> = [<span class="string">'red'</span>, <span class="string">'blue'</span>];</span><br><span class="line"><span class="atom">colors</span>[<span class="atom">colors</span>.<span class="atom">length</span>] = <span class="string">'green'</span>;</span><br><span class="line"><span class="atom">colors</span>[<span class="atom">colors</span>.<span class="atom">length</span>] = <span class="string">'red'</span>;</span><br></pre></td></tr></table></figure>
<p>由于数组最后一项的索引始终是length－1， 因此下一个新项的位置就是length。</p>
<h4 id="检测数组">检测数组</h4><p>对于全局作用域而言，使用instanceof操作符就能确定某个对象是否为数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">	<span class="comment">// is Array</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>instanceof操作符的问题在于它假定只有一个全局执行环境。</strong></p>
<p>ECMAScript5新增了Array.isArray()方法，目的是不管它是在哪个执行环境中创建的都可以确定是不是数组。</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">Array</span>.<span class="built_in">isArray</span>(value)) &#123;</span><br><span class="line">	<span class="comment">//is Array</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="转换方法">转换方法</h4><p>所有对象都具有toLocalString(), toString()和valueOf()方法。调用toString()方法会返回数组中每个值的字符串形式拼接而成的一个以逗号分割的字符串，而调用valueOf方法返回的还是数组。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>];</span><br><span class="line">colors.toString(); <span class="comment">//red, blue</span></span><br><span class="line">colors.valueOf(); <span class="comment">//red, blue</span></span><br></pre></td></tr></table></figure>
<h4 id="栈方法">栈方法</h4><p>栈是一种LIFO（Last In First Out）的数据结构，即最新添加的元素最早被移除。栈中数据的添加和删除都只发生在栈的顶部。</p>
<p>ECMAScript为数字提供了push()和pop()方法，以实现类似栈的行为。</p>
<p>push()方法可以接受任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。</p>
<p>pop()方法则从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。</p>
<h4 id="队列方法">队列方法</h4><p>栈数据结构访问规则是LIFO，而队列数据结构的访问规则是FIFO（First In First Out）。队列在列表的末端添加项，从列表的前端移除项。</p>
<p>shift()方法移除数组的第一个元素并返回该项，同时将数组的长度减1。</p>
<p>ECMAScript还提供了unshift()方法。它能在数组前端添加任意元素并返回新数组的长度。</p>
<h4 id="重排序方法">重排序方法</h4><p>数组中有两个可以直接用来排序的方法：reverse()和sort()。</p>
<p>reverse()方法会反转数组项的顺序。</p>
<p>sort()接收一个比较函数作为参数，比较函数接收两个参数。</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> compareFun(<span class="keyword">value</span><span class="number">1</span>, <span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">value</span><span class="number">1</span> - <span class="keyword">value</span><span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="操作方法">操作方法</h4><blockquote>
<p>concat()方法可以基于当前数组中的所有项创建一个新的数组。</p>
</blockquote>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>];</span><br><span class="line"><span class="keyword">var</span> colors2 = colors.<span class="keyword">concat</span>(<span class="string">'yellow'</span>, [<span class="string">'black'</span>, <span class="string">'brown'</span>]);</span><br><span class="line"></span><br><span class="line">colors; <span class="comment">// red, blue</span></span><br><span class="line">colors2; <span class="comment">// red, blue, yellow, black, brown</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>slice()方法能够基于当前数组中的一个或多个项创建一个新数组</p>
</blockquote>
<p>slice()方法接收一个或两个参数，即要返回项的起始和结束位置。当只有一个参数时，slice()方法返回从该参数开始到当前数组结尾的所有项。</p>
<p><strong>slice()方法不影响原始数组。</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> colors</span> = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>, <span class="string">"yellow"</span>, <span class="string">"purple"</span>];</span><br><span class="line"><span class="variable"><span class="keyword">var</span> colors2</span> = colors.slice(<span class="number">1</span>);</span><br><span class="line"><span class="variable"><span class="keyword">var</span> colors3</span> = colors.slice(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">colors2;   <span class="comment">//green,blue,yellow,purple</span></span><br><span class="line">colors3;   <span class="comment">//green,blue,yellow</span></span><br></pre></td></tr></table></figure>
<p><strong>slice()方法的参数中有负数时候，则用数组长度加上该数来确定相应的位置。</strong></p>
<p>splice()主要用途是向数组的中部插入项。</p>
<p>splice()三大作用：</p>
<blockquote>
<ul>
<li>删除：可以删除任意数量的项，只需指定2个参数（要删除的第一项的位置和要删除的项数）。如splice(0, 2)会删除数组中的前两项</li>
<li>插入：可以向指定位置插入任意数量的项，只需提供3个参数（起始位置，0(要删除的项数)和要插入的项）。如果要插入多个项，可以再传入第四、第五以志任意多项。如splice(2, 0, ‘red’, ‘green’)会从当前数组的位置2开始插入字符串’red’和’green’</li>
<li>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数（起始位置，要删除的项数和要插入的任意数量的项）。插入的项数不必与删除的项数相等。如splice(2, 1, ‘red’, ‘green’)会删除当前数组位置为2的元素，然后再从位置2开始插入字符串’red’和’green’</li>
</ul>
</blockquote>
<p>splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除元素，则返回一个空数组。</p>
<h4 id="位置方法">位置方法</h4><p>ECMAScript为数组实例添加了两个方法：indexOf()和lastIndexOf()。这两个方法都接收两个参数：要查找的项和表示查找起点位置的索引（可选的）。</p>
<p>indexOf()方法从数组的开头（位置0）开始向后查找，lastIndexOf()则从数组的末尾开始向前查找。</p>
<p>这两个方法都返回要查找的项在数组中的位置，没有找到的话返回－1。</p>
<h4 id="迭代方法">迭代方法</h4><p>ECMAScript为数组定义了5个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和运行该函数的作用域对象——影响this的值（可选的）。传入这些方法中的函数会接收三个参数：数组项的值，该项的数组中的位置和数组对象本身。</p>
<blockquote>
<ul>
<li>every()：对数组的每一元素运行给定函数，如果该函数每一项都返回true，则返回true</li>
<li>filter()：对数组中每一元素运行给定函数，返回该函数会返回true的元素组成的数组</li>
<li>forEach()：对数组中每一元素运行给定函数，无返回值</li>
<li>map()：对数组中每一元素运行给定函数，返回每次函数调用的结果组成的数组</li>
<li>some()：对数组中每一元素运行给定函数，如果该函数任一项返回true，则返回true</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">var filterResult = numbers.filter(function(item, index, <span class="built_in">array</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">filterResult; <span class="comment">// 3, 4, 5</span></span><br></pre></td></tr></table></figure>
<p>map()也返回一个数组，而这个数组的每一项都是原始数组中的对应项上运行传入函数的结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">var mapResult = numbers.<span class="built_in">map</span>(function(item, index, <span class="built_in">array</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mapResult; <span class="comment">// [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure>
<h4 id="归并方法">归并方法</h4><p>ECMAScript5新增了两个归并数组的方法：reduce()和reduceRight()。这两个方法都会迭代数组的所有元素，然后构建一个最终返回的值。</p>
<p>reduce()方法从数组的第一个元素开始，逐个遍历到最后，reduceRight()则从数组的最后一项开始，向前遍历到第一个元素。</p>
<p>这两个方法都接收两个参数：一个在每一元素上调用的函数和作为归并基础的初始值（可选的）。传给redux()和reduceRight()的函数接收4个参数：前一个值，当前值，元素的索引和数组对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">var sum = values.reduce(function(prev, cur, index, <span class="built_in">array</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sum; <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>第一次执行回调函数，prev是1， cur是2.第二次prev是3（1+2），cur是3（数组第三项）。这个过程会持续到把数组中的每一项都访问一遍，最后返回结果。</p>
<p>reduceRight()的作用类似，只不过方向相反而已。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">var sum = values.reduceRight(function(prev, cur, index, <span class="built_in">array</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sum; <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>第一次执行回调函数，prev是5，cur是4。</p>
<h3 id="Date类型">Date类型</h3><p>Date.parse()方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。</p>
<p>Date.parse()参数的可选格式：</p>
<blockquote>
<ul>
<li>“月／日／年”：如6/12/2015</li>
<li>“英文月 日, 年”：如January 12， 2015</li>
<li>“英文星期几 英文月 日 年 时: 分: 秒: 时区”：如Tue May 25 2015 00:00:00 GMT-0700</li>
<li>ISO 8601扩展格式YYYY-MM-DDTHH:mm:ss:sssZ，如2015-05-25T00:00:00</li>
</ul>
</blockquote>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">date</span> = <span class="literal">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span><span class="built_in">.</span>parse(<span class="string">'May 25, 2015'</span>));</span><br></pre></td></tr></table></figure>
<p>Date.UTC()方法也返回表示日期的毫秒数，参数分别是年份，月份（从0开始），日（1－31），小时数（0-23），分钟，秒以及毫秒。只有年月参数是必须按的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var date = <span class="keyword">new</span> Date(Date.UTC(<span class="number">2000</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">var date1 = <span class="keyword">new</span> Date(Date.UTC(<span class="number">2015</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">55</span>, <span class="number">55</span>));</span><br></pre></td></tr></table></figure>
<p><strong>创建Date对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var date = <span class="keyword">new</span> Date(<span class="number">2015</span>, <span class="number">0</span>);</span><br><span class="line">var date1 = <span class="keyword">new</span> Date(<span class="number">2015</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">45</span>, <span class="number">25</span>);</span><br></pre></td></tr></table></figure>
<p>ECMAScript添加了Date.now()方法，返回表示调用这个方法的日期和时间的毫秒数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var <span class="operator"><span class="keyword">start</span> = <span class="built_in">Date</span>.<span class="keyword">now</span>();</span></span><br><span class="line"></span><br><span class="line">var <span class="operator"><span class="keyword">stop</span> = <span class="built_in">Date</span>.<span class="keyword">now</span>();</span></span><br><span class="line"></span><br><span class="line">var result = <span class="operator"><span class="keyword">stop</span> - <span class="keyword">start</span>;</span></span><br></pre></td></tr></table></figure>
<p>在不支持Date.now()的浏览器中，使用＋操作符把Date对象转成字符串。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var <span class="operator"><span class="keyword">start</span> = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"></span><br><span class="line">var <span class="operator"><span class="keyword">stop</span> = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"></span><br><span class="line">var result = <span class="operator"><span class="keyword">stop</span> - <span class="keyword">start</span>;</span></span><br></pre></td></tr></table></figure>
<h3 id="RegExp类型">RegExp类型</h3><p>ECMAScript通过RegExp类型来支持正则表达式。</p>
<p>正则表达式的匹配模式支持下面3个标志：</p>
<blockquote>
<ul>
<li>g：全局模式，即模式将应用于所有字符串，而非在发现第一个匹配项时立即停止</li>
<li>i：不区分大小写模式</li>
<li>m：多行模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项</li>
</ul>
</blockquote>
<p>模式中的所有<strong>元字符</strong>都必须转义。正则表达式中的元字符包括：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">( <span class="collection">[ <span class="collection">&#123; \ ^ $ | ) ? * + . ]</span> &#125;</span></span></span><br></pre></td></tr></table></figure>
<p>定义正则表达式可以采用字面量的形式，也可以采用RegExp构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是标志字符串（可选的）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'[bc]at'</span>, <span class="string">'i'</span>);</span><br></pre></td></tr></table></figure>
<p><strong>传递给RegExp构造函数的两个参数都是字符串，所有元字符都必须双重转义。</strong></p>
<h4 id="RegExp实例属性">RegExp实例属性</h4><p>RegExp的每个实例都具有下列属性：</p>
<blockquote>
<ul>
<li>global：布尔值，表示是否设置了g标志</li>
<li>ignoreCase：布尔值，表示是否设置了i标志</li>
<li>lastIndex：整数，表示是否设置了下一个匹配项的字符位置，从0算起</li>
<li>multiline：布尔值，表示是否设置了m标志</li>
<li>source：正则表达式的字符串形式</li>
</ul>
</blockquote>
<h4 id="RegExp实例方法">RegExp实例方法</h4><p>RegExp对象的主要方法是<strong>exec()</strong>，该方法是专门为捕获组而设计的。exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null。返回的数组虽然是Array的实例，但包含两个额外的属性：index和input。index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var text = 'mom <span class="keyword">and</span> dad <span class="keyword">and</span> baby';</span><br><span class="line">var pattern = /mom( <span class="keyword">and</span> dad( <span class="keyword">and</span> baby)?)?/gi;</span><br><span class="line"></span><br><span class="line">var <span class="operator">matches</span> = pattern.exec(text);</span><br><span class="line"><span class="operator">matches</span>.index; // <span class="number">0</span></span><br><span class="line"><span class="operator">matches</span>.input; // mom <span class="keyword">and</span> dad <span class="keyword">and</span> baby</span><br><span class="line"><span class="operator">matches</span>[<span class="number">0</span>]; // mom <span class="keyword">and</span> dad <span class="keyword">and</span> baby</span><br><span class="line"><span class="operator">matches</span>[<span class="number">1</span>]; // <span class="keyword">and</span> dad <span class="keyword">and</span> baby</span><br><span class="line"><span class="operator">matches</span>[<span class="number">2</span>]; // <span class="keyword">and</span> baby</span><br></pre></td></tr></table></figure>
<p>exec()方法，即使在模式字符串中设置了全局标志(g)，它每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一匹配项的信息，而在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项。</p>
<p><strong>test()</strong>方法，接受一个字符串参数。在模式与该参数匹配的情况下返回true，否则返回false。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">'00-000'</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/\d&#123;2&#125;-\d&#123;3&#125;/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pattern.test(text)) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'matched'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正则表达式的valueOf()方法返回正则表达式本身。</strong></p>
<h4 id="RegExp的属性">RegExp的属性</h4><blockquote>
<ul>
<li>input($_)：最近一次要匹配的字符串</li>
<li>lastMatch($&amp;)：最近一次的匹配项</li>
<li>lastParen($+)：最近一次匹配的捕获组</li>
<li>leftContext($`)：input字符串中lastMatch之前的文本</li>
<li>multiline($*)：布尔值，表示是否所有表达式都使用多行模式</li>
<li>rightContext($’)：input字符串中lastMatch之后的文本</li>
</ul>
</blockquote>
<p>另外还有9个用于存储捕获组的构造函数属性。访问这些属性的语法是RegExp.$1，RegExp.$2……RegExp.$9，分别用于存储第一，第二到第九个匹配的捕获组。在调用exec()或test()方法时，这些属性会自动被填充。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var text = <span class="string">'this has been a short summer'</span>;</span><br><span class="line">var pattern = /(..)or(.)/g;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pattern.test(text)) &#123;</span><br><span class="line">	RegExp.<span class="variable">$1</span>; // sh</span><br><span class="line">	RegExp.<span class="variable">$2</span>; // t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Function类型">Function类型</h3><p>函数实际上是对象。每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际也是一个指向函数对象的指针，不会与某个函数绑定。</p>
<p><strong>函数是对象，函数名是指针。</strong></p>
<p>由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同，即一个函数可能会有多个名子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">sum</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">var anotherSum = sum;</span><br><span class="line">anotherSum(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">sum = null;</span><br><span class="line">anotherSum(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<h4 id="函数声明与函数表达式">函数声明与函数表达式</h4><p>解析器率先读取函数声明，并使其在执行任何代码之前可用；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。</p>
<h4 id="作为值的函数">作为值的函数</h4><p>因为ECMAScript中的函数名本身就是变量，所以函数也可以作为值来使用。即不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeFunction</span><span class="params">(someFunction, someArgument)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> someFunction(someArgument);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，也可以从一个函数中返回另一个函数。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span><span class="params">(pname)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(o1, o2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> value1 = o1[pname];</span><br><span class="line">		<span class="keyword">var</span> value2 = o2[pname];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> value1 - value2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数内部属性">函数内部属性</h4><p>函数内部，有两个特色的对象：arguments和this。arguments是一个类数组对象，包含着传入函数中的所有参数。arguments有一个名为callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">fatorial</span><span class="params">(num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(num &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="function">num * <span class="title">facorial</span><span class="params">(num - <span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用arguments.callee实现上面的代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">fatorial</span><span class="params">(num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(num &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> num * arguments.callee(num - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>this对象</strong>引用的是函数赖以执行的环境对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">'red'</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">	color: <span class="string">'blue'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getColor(); <span class="comment">// red</span></span><br><span class="line"></span><br><span class="line">o.getColor = getColor;</span><br><span class="line">o.getColor(); <span class="comment">// blue</span></span><br></pre></td></tr></table></figure>
<p>在调用函数之前，this的值并不确定，因此this可能会在代码执行过程中引用不同的对象。当在全局调用时，this引用的是全局对象window；当把函数赋值给对象后，this就指向该对象。</p>
<p>ECMAScript5也规范了另外一个函数对象的属性：caller。该属性中保存着调用当前函数的引用，如果在全局作用域中调用当前函数，caller的值为null。</p>
<p><strong>callee和caller都不能使用在严格模式下。</strong></p>
<h4 id="函数属性和方法">函数属性和方法</h4><p>ECMAScript中的函数是对象，因此函数也有属性和方法。每个函数都包含两个属性：length和prototype。length属性表示函数希望接收的命名参数个数。prototype属性保存函数所有的实例方法。prototype属性是无法枚举的。</p>
<p>每个函数都包含两个非继承的方法：<strong>apply()和call()</strong>。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。</p>
<p>apply()方法接收两个参数：一个是在其中运行函数的作用域，另外一个是参数数组（可以是数组Array的实例，也可以是arguments对象）。</p>
<p>call()方法第一个参数是其中运行函数的作用域，其他参数是单个的参数列表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">sum</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum.call(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line">sum.apply(<span class="keyword">this</span>, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p><strong>apply()和call()真正强大的地方是能够扩充函数赖以运行的作用域。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">'red'</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">	color: <span class="string">'blue'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getColor(); <span class="comment">// red</span></span><br><span class="line"></span><br><span class="line">getColor.call(<span class="keyword">this</span>); <span class="comment">// red</span></span><br><span class="line">getColor.call(<span class="built_in">window</span>); <span class="comment">// red</span></span><br><span class="line">getColor.call(o); <span class="comment">// blue</span></span><br></pre></td></tr></table></figure>
<p>使用call()或apply()方法来扩充作用域的最大好处是对象不需要与方法有任何耦合关系。</p>
<p><strong>bind()</strong>方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">'red'</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">	color: <span class="string">'blue'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> objectColor = getColor.bind(o);</span><br><span class="line">objectColor(); <span class="comment">// blue</span></span><br></pre></td></tr></table></figure>
<h3 id="基本包装类型">基本包装类型</h3><p>ECMAScript提供了3个特殊的引用类型：Boolean、Number和String。</p>
<p>引用类型和基本包装类型的主要区别就是<strong>对象的生存期</strong>。使用new操作符创建的引用类型的实例如，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。即不能在运行时为基本类型值添加属性和方法。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">str</span> = <span class="string">'bzn come from xxx'</span>;</span><br><span class="line"><span class="keyword">str</span>.name = <span class="string">'ok'</span>;</span><br><span class="line"><span class="keyword">str</span>.name; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p><strong>对基本包装类型的实例调用typeof会返回“object”。</strong></p>
<h4 id="Boolean类型">Boolean类型</h4><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> falseObj = new <span class="type">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="literal">result</span> falseObj &amp;&amp; <span class="literal">true</span>;</span><br><span class="line"><span class="literal">result</span>; // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> falseObj = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="literal">result</span> falseObj &amp;&amp; <span class="literal">true</span>;</span><br><span class="line"><span class="literal">result</span>; // <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>由于布尔表达式中的所有对象都会被转换为true，因此falseObj对象在布尔表达式中代表的是true。</p>
<p>基本类型与引用类型的布尔值还有两个区别：</p>
<blockquote>
<ul>
<li>typeof操作符对基本类型返回“boolean”，而对引用类型返回“object”</li>
<li>由于Boolean对象是Boolean类型的实例，所以使用instanceof操作符测试Boolean对象都会返回true，而测试基本类型的布尔值返回false</li>
</ul>
</blockquote>
<h4 id="Number类型">Number类型</h4><p><strong>toFixed()</strong> 方法会按照指定的小数位返回数值的字符串表示。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">num</span>.toFixed(<span class="number">2</span>); <span class="comment">// 10.00</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">10.0005</span>;</span><br><span class="line"><span class="built_in">num</span>.toFixed(<span class="number">3</span>); <span class="comment">// 10.006</span></span><br></pre></td></tr></table></figure>
<p><strong>toExponential()</strong>方法返回以指数表示法(e表示法)表示的数值的字符串形式，接收一个参数，指定输出结果中的小数位数。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">num</span>.toExponential(<span class="number">1</span>); <span class="comment">// 1.0e+1</span></span><br></pre></td></tr></table></figure>
<p><strong>toPrecision()</strong>方法会返回固定大小格式，也可能返回指数格式，接收一个参数，表示数值的所有数字的位数，不包含指数部分。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">99</span>;</span><br><span class="line"><span class="built_in">num</span>.toPrecision(<span class="number">1</span>); <span class="comment">// 1e+2</span></span><br><span class="line"><span class="built_in">num</span>.toPrecision(<span class="number">2</span>); <span class="comment">// 99</span></span><br><span class="line"><span class="built_in">num</span>.toPrecision(<span class="number">3</span>); <span class="comment">// 99.0</span></span><br></pre></td></tr></table></figure>
<p>使用typeof操作符测试基本类型数值时，始终返回“number”，而在测试Number对象时，则会返回“object”。Number对象是Number类型的实例，而基本类型的数值则不是。</p>
<h4 id="String_类型">String 类型</h4><p><strong>字符方法</strong></p>
<blockquote>
<p>charAt()和charCodeAt()</p>
</blockquote>
<p>以上两个方法用于访问字符串中特定字符，都接收一个参数，即基于0的字符位置。</p>
<p>charAt()方法以单字符字符串的形式返回给定位置的那个字符。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">str</span> = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">str</span>.charAt(<span class="number">1</span>); <span class="comment">// e</span></span><br></pre></td></tr></table></figure>
<p>如果不需要字符，而需要字符编码，则使用charCodeAt()方法。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">str</span> = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">str</span>.charCodeAt(<span class="number">1</span>); <span class="comment">//101</span></span><br></pre></td></tr></table></figure>
<p>访问字符串中特定位置的字符，还可以使用方括号加数字索引。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">str</span> = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">str</span>[<span class="number">2</span>]; <span class="comment">// l</span></span><br></pre></td></tr></table></figure>
<p><strong>字符串操作方法</strong></p>
<blockquote>
<p>concat()：将一个或多个字符串拼接起来，返回拼接得到的新字符串</p>
</blockquote>
<p>concat()方法可以接收任意多个参数。</p>
<blockquote>
<p>slice(), substr()和substring()</p>
</blockquote>
<p>上面三个方法都会返回被操作字符串的一个子字符串，都接收一个或两个参数。第一个参数指定字符串的开始位置，第二个参数表示子字符串结束位置。 slice()和substring()的第二个参数指定的是子字符串最后一个字符后面的位置；substr()的第二个参数指定的则是返回的字符个数。如果不传递第二个参数，则将字符串的长度作为结束位置。</p>
<p>当传入的参数位负数时候：</p>
<blockquote>
<ul>
<li>slice()方法会将传入的负值与字符串长度相加</li>
<li>substr()方法将第一个参数加上字符串长度，第二个参数转换为0</li>
<li>substring()方法会把所有负值都转换为0</li>
</ul>
</blockquote>
<p><strong>字符串位置方法</strong></p>
<blockquote>
<p>indexOf()和lastIndexOf()</p>
</blockquote>
<p>这两个方法用于从字符串中查找子字符串，然后返回子字符串的位置，如果没有找到则返回－1。区别在于：<strong>indexOf()方法从字符串的开头向后搜索，而lastIndexOf()方法是从字符串的末尾向前搜索子字符串。</strong></p>
<p>这两个方法都可以接收可选的第二个参数，表示从字符串中的哪个位置开始搜索。</p>
<p><strong>trim()方法</strong></p>
<p>trim()方法会创建一个字符串的副本，删除前后的所有空格，然后返回结果。</p>
<p>trimLeft()和trimRight()分别会删除字符串开头和结尾的空格。</p>
<p><strong>字符串大小写转换方法</strong></p>
<blockquote>
<p>toLowerCase() / toUpperCase()<br>toLocalLowerCase() / toLocalUpperCase()</p>
</blockquote>
<p><strong>字符串模式匹配方法</strong></p>
<blockquote>
<p>match()</p>
</blockquote>
<p>match()方法只接收一个参数，正则表达式或RegExp对象。在字符串上调用match方法，本质上和调用RegExp的exec()方法相同。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> text</span> = 'cat, bat, sat';</span><br><span class="line"><span class="variable"><span class="keyword">var</span> pattern</span> = /.at/;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与pattern.exec(text)相同</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> matches</span> = text.match(pattern);</span><br><span class="line">matches.index; <span class="comment">// 0</span></span><br><span class="line">matches[<span class="number">0</span>]; <span class="comment">// cat</span></span><br><span class="line">pattern.lastIndex; <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>search()</p>
</blockquote>
<p>search()方法接收一个参数，由字符串或RegExp对象指定的正则表达式，返回字符串中第一个匹配项的索引，如果没有匹配项，则返回－1。search()方法从字符串开头向后查找。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">'cat, bat'</span>;</span><br><span class="line"><span class="keyword">var</span> pos = text.search(<span class="regexp">/at/</span>);</span><br><span class="line">pos; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>replace()</p>
</blockquote>
<p>replace()方法接收两个参数：第一个参数是字符串或RegExp对象，第二个参数是字符串或函数。如果第一个参数是字符串，那么只会替换第一个字符串，如果要替换所有的子字符串，则只能提供一个正则表达式，且指定全局标志。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = 'bat, cat, fat';</span><br><span class="line"><span class="keyword">var</span> <span class="literal">result</span> = text.replace('at', 'ond');</span><br><span class="line"><span class="literal">result</span>; //bond, cat, fat</span><br><span class="line"></span><br><span class="line"><span class="literal">result</span> = text.replace(/at/g, 'ond');</span><br><span class="line"><span class="literal">result</span>; // bond, cond, fond</span><br></pre></td></tr></table></figure>
<p>如果第二个参数是字符串，则可以使用一些特殊的字符序列，将正则表达式操作得到的值插入到结果字符串中。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = 'cat, bat, fat';</span><br><span class="line"><span class="literal">result</span> = text.replace(/(.at)/g, 'h($<span class="number">1</span>)');</span><br><span class="line"><span class="literal">result</span>; //h(cat), h(bat), h(fat)</span><br></pre></td></tr></table></figure>
<p>replace()方法的第二个参数也可以是一个函数。在只有一个匹配项的情况下，会向这个函数传递3个参数：模式的匹配项，模式匹配项在字符串中的位置和原始字符串。当正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项，第一个捕获组，第二个捕获组……，最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEscape</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> text.replace(<span class="regexp">/[&lt;&gt;"&amp;]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, pos, originalText</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">switch</span>(match) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'&lt;'</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">'&amp;lt;'</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'&gt;'</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">'&amp;gt'</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'&amp;'</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">'&amp;amp;'</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'\"'</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">'&amp;quot;'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">htmlEscape(<span class="string">"&lt;p class=\"greeting\"&gt;Hello world!&lt;/p&gt;"</span>); <span class="comment">//&amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&amp;lt;/p&amp;gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>split()</p>
</blockquote>
<p>split()方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象。split()可以接收第二个参数，用于指定数组的大小。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var text = <span class="string">'bat, cat, fat'</span>;</span><br><span class="line">text.split(<span class="string">','</span>); <span class="regexp">//</span>[<span class="string">'bat'</span>, <span class="string">'cat'</span>, <span class="string">'fat'</span>]</span><br><span class="line">text.split(<span class="string">','</span>, <span class="number">2</span>); <span class="regexp">//</span> [<span class="string">'bat'</span>, <span class="string">'cat'</span>]</span><br><span class="line">text.split(<span class="regexp">/[^\,]+/</span>); <span class="regexp">//</span> [<span class="string">''</span>, <span class="string">','</span>, <span class="string">''</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>localCompare()方法</p>
</blockquote>
<p>localCompare()方法比较两个字符串，并返回下列值中的一个：</p>
<blockquote>
<ul>
<li>如果字符串在字母表中应该排在字符串参数之前，则返回一个负数</li>
<li>如果字符串等于字符串参数，则返回0</li>
<li>如果字符串在字母表中应该排在字符串参数之后，则返回一个正数</li>
</ul>
<p>fromCharCode()</p>
</blockquote>
<p>fromCharCode()是一个静态方法，接收一个或多个字符编码，然后将它们转换成一个字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String.fromCharCode(<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>);  <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
<h3 id="单体内置对象">单体内置对象</h3><p>ECMAScript对内置对象的定义是：由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。</p>
<h4 id="Global对象">Global对象</h4><p>isNaN(), isFinite(), parseInt()及parseFloat()等都是Global对象的方法。</p>
<p><strong>URL编码方法</strong></p>
<p>Global对象的encodeURI()和encodeURIComponent()方法可以对URI进行编码。</p>
<p>encodeURI()主要用于整个URI，而encodeURIComponent()主要用于对URI中的某一段进行编码。</p>
<p>encodeURI()不会对本身属于URI的特殊字符进行编码，如冒号，正斜杠，？＃等；而encodeURIComponent()则会对它发现的任何非法标准字符进行编码。</p>
<p>与encodeURI()和encodeURIComponent()对应的两个方法分别是decodeURI()和decodeURIComponent()。</p>
<p><strong>eval()方法</strong></p>
<p>eval()方法类似一个完整的ECMAScript解析器，它只接收一个参数，即要执行的ECMAScript字符串。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval<span class="list">(<span class="quoted">'console</span>.log<span class="list">(<span class="string">"hi"</span>)</span>')</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>当解析器发现代码中调用eval()方法时，它会将传入的参数当作实际的ECMAScript语句来解析。</p>
<p>在eval()中创建的任何变量和函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中，它们只在eval()执行的时候创建。</p>
<p>严格模式下，在外部访问不到eval()中创建的任何变量或函数，为eval赋值也会导致错误。</p>
<h4 id="Math对象">Math对象</h4><p><strong>min()和max()方法</strong></p>
<p>min()和max()方法用于确定一组数值中的最小值和最大值。这两个方法都可以接收任意多个数值参数。</p>
<p>要找出数组中的最大值或最小值，可以使用apply()方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, values);</span><br></pre></td></tr></table></figure>
<p><strong>舍入方法</strong></p>
<blockquote>
<ul>
<li>Math.ceil()执行向上舍入</li>
<li>Math.floor()执行向下舍入</li>
<li>Math.round()执行标准舍入</li>
</ul>
</blockquote>
<p><strong>random()方法</strong></p>
<p>Math.random()方法返回大于0小于1的一个随机数。套用下面的公司，可以利用Math.random()从某个整数范围内随机选择一个值。</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = Math.<span class="built_in">floor</span>(Math.<span class="built_in">random</span>() * 可能值的总数 + 第一个可能的值)</span><br></pre></td></tr></table></figure>
<p>上面的代码可以使用如下方法替代：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectRandom</span>(<span class="params">lower, upper</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> choices = upper - lower + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * choices + lower);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">selectRandom(<span class="number">2</span>, <span class="number">15</span>); <span class="comment">// 介于2到15之前的随机数</span></span><br></pre></td></tr></table></figure>

      
      

      <!-- page.path 表示不含根路径的页面网址。还有数种方式可以匹配页面，在此不赘述。 -->
        
    </div>
    
  </div>
  
    
<div class="copyright">
  <p><span>本文标题:</span><a href="/2015/11/18/JavaScript引用类型/">JavaScript引用类型</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 baizn 的个人博客">baizn</a></p>
  <p><span>发布时间:</span>2015年11月18日 - 11时11分</p>
  <p><span>最后更新:</span>2015年11月18日 - 11时11分</p>
  <p>
    <span>原始链接:</span><a href="/2015/11/18/JavaScript引用类型/" title="JavaScript引用类型">http://baizn.github.io/2015/11/18/JavaScript引用类型/</a>
    <span class="btn" data-clipboard-text="原文: http://baizn.github.io/2015/11/18/JavaScript引用类型/　　作者: baizn" title="点击复制文章链接">
        <i class="fa fa-clipboard"></i>
    </span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。</p>
  <script src="/js/clipboard.min.js"></script>
  <script> var clipboard = new Clipboard('.btn'); </script>
</div>
<style type="text/css">
  .copyright p .btn {
    margin-left: 1em;
  }
  .copyright:hover p .btn::after {
    content: "复制"
  }
  .copyright p .btn:hover {
      color: gray;
      cursor: pointer;
    };
</style>



<nav id="article-nav">
  
    <div id="article-nav-newer" class="article-nav-title">
      <a href="/2015/11/18/React开发躺过的坑/">
        React开发躺过的坑
      </a>
    </div>
  
  
    <div id="article-nav-older" class="article-nav-title">
      <a href="/2015/11/11/JavaScript执行环境、作用域及垃圾收集/">
        JavaScript执行环境、作用域及垃圾收集
      </a>
    </div>
  
</nav>

  
</article>

<!-- 默认显示文章目录，在文章---前输入toc: false关闭目录 -->
<!-- Show TOC and tocButton in default, Hide TOC via putting "toc: false" before "---" at [post].md -->
<div id="toc" class="toc-article">
<strong class="toc-title">文章目录</strong>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript引用类型"><span class="toc-number">1.</span> <span class="toc-text">JavaScript引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Array类型"><span class="toc-number">1.1.</span> <span class="toc-text">Array类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#检测数组"><span class="toc-number">1.1.1.</span> <span class="toc-text">检测数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#转换方法"><span class="toc-number">1.1.2.</span> <span class="toc-text">转换方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#栈方法"><span class="toc-number">1.1.3.</span> <span class="toc-text">栈方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#队列方法"><span class="toc-number">1.1.4.</span> <span class="toc-text">队列方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重排序方法"><span class="toc-number">1.1.5.</span> <span class="toc-text">重排序方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#操作方法"><span class="toc-number">1.1.6.</span> <span class="toc-text">操作方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#位置方法"><span class="toc-number">1.1.7.</span> <span class="toc-text">位置方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#迭代方法"><span class="toc-number">1.1.8.</span> <span class="toc-text">迭代方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#归并方法"><span class="toc-number">1.1.9.</span> <span class="toc-text">归并方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Date类型"><span class="toc-number">1.2.</span> <span class="toc-text">Date类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RegExp类型"><span class="toc-number">1.3.</span> <span class="toc-text">RegExp类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RegExp实例属性"><span class="toc-number">1.3.1.</span> <span class="toc-text">RegExp实例属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RegExp实例方法"><span class="toc-number">1.3.2.</span> <span class="toc-text">RegExp实例方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RegExp的属性"><span class="toc-number">1.3.3.</span> <span class="toc-text">RegExp的属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Function类型"><span class="toc-number">1.4.</span> <span class="toc-text">Function类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#函数声明与函数表达式"><span class="toc-number">1.4.1.</span> <span class="toc-text">函数声明与函数表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#作为值的函数"><span class="toc-number">1.4.2.</span> <span class="toc-text">作为值的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数内部属性"><span class="toc-number">1.4.3.</span> <span class="toc-text">函数内部属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数属性和方法"><span class="toc-number">1.4.4.</span> <span class="toc-text">函数属性和方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本包装类型"><span class="toc-number">1.5.</span> <span class="toc-text">基本包装类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Boolean类型"><span class="toc-number">1.5.1.</span> <span class="toc-text">Boolean类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Number类型"><span class="toc-number">1.5.2.</span> <span class="toc-text">Number类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String_类型"><span class="toc-number">1.5.3.</span> <span class="toc-text">String 类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单体内置对象"><span class="toc-number">1.6.</span> <span class="toc-text">单体内置对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Global对象"><span class="toc-number">1.6.1.</span> <span class="toc-text">Global对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Math对象"><span class="toc-number">1.6.2.</span> <span class="toc-text">Math对象</span></a></li></ol></li></ol></li></ol>
</div>
<style type="text/css">
  .left-col .switch-btn {
    display: none;
  }
  .left-col .switch-area {
    display: none;
  }
</style>

<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">
<script type="text/javascript">
  var toc_button= document.getElementById("tocButton");
  var toc_div= document.getElementById("toc");
  /* Show or hide toc when click on tocButton.
  通过点击设置的按钮显示或者隐藏文章目录.*/
  toc_button.onclick=function(){
  if(toc_div.style.display=="none"){
  toc_div.style.display="block";
  toc_button.value="隐藏目录";
  document.getElementById("switch-btn").style.display="none";
  document.getElementById("switch-area").style.display="none";
  }
  else{
  toc_div.style.display="none";
  toc_button.value="显示目录";
  document.getElementById("switch-btn").style.display="block";
  document.getElementById("switch-area").style.display="block";
  }
  }
</script>


<div class="share">
	<div class="bdsharebuttonbox">
	<a href="#" class="bds_more" data-cmd="more"></a>
	<a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
	<a href="#" class="bds_copy" data-cmd="copy" title="复制网址"></a>
	<a href="#" class="bds_mail" data-cmd="mail" title="通过邮件分享"></a>
	<a href="#" class="bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
	</div>
	<script>
	window._bd_share_config={
		"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
	</script>
</div>



  
  <div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="JavaScript引用类型" data-title="JavaScript引用类型" data-url="http://baizn.github.io/2015/11/18/JavaScript引用类型/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"baizn"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>

  





    <style type="text/css">
    #scroll {
      display: none;
    }
    </style>
    <div class="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#ds-thread" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
    </div>


  
  
    
    <div  class="post-nav-button">
    <a href="/2015/11/18/React开发躺过的坑/" title="上一篇: React开发躺过的坑">
    <i class="fa fa-angle-left"></i>
    </a>
    <a href="/2015/11/11/JavaScript执行环境、作用域及垃圾收集/" title="下一篇: JavaScript执行环境、作用域及垃圾收集">
    <i class="fa fa-angle-right"></i>
    </a>
    </div>
  

</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2016 baizn
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的静态博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减双栏 Hexo 博客主题">Yelee</a> by MOxFIVE
        </div>
    </div>
    <div class="visit">
      <span id="busuanzi_container_site_pv" style='display:none'>
        <span id="site-visit" >本站到访数: 
        <span id="busuanzi_value_site_uv"></span>
        </span>
      </span>
      <span id="busuanzi_container_page_pv" style='display:none'>
        <span id="page-visit">, 本页阅读量: 
        <span id="busuanzi_value_page_pv"></span>
        </span>
      </span>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>

  <style type="text/css">
    body {
      background: lightgray;
    }
    #container .left-col {
      background: white;
    }
    .article-inner {
      background: white;
    }
    .post-nav-button {
      background: #ececec;
    }
    #header .header-nav .social #GitHub {
      background-color: #bfd3ec;
    }
  </style>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
<a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
<a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>